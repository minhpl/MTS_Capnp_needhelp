// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: message.capnp

#ifndef CAPNP_INCLUDED_881a44bf3eccf134_
#define CAPNP_INCLUDED_881a44bf3eccf134_

#include <capnp/generated-header-support.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 6000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(99bfd28ffda77d09);
CAPNP_DECLARE_SCHEMA(d8aa76dc72b09879);
CAPNP_DECLARE_SCHEMA(cb4f4dfeeeed3f29);
CAPNP_DECLARE_SCHEMA(a249b85fb5ab8dcc);
CAPNP_DECLARE_SCHEMA(adc051dcaf5d17ba);
CAPNP_DECLARE_SCHEMA(e871a5fb9f1ab855);
CAPNP_DECLARE_SCHEMA(8543958636423507);
CAPNP_DECLARE_SCHEMA(ce26efce5dffed46);
CAPNP_DECLARE_SCHEMA(f0374a1e38e6a0d7);
CAPNP_DECLARE_SCHEMA(b327ba4a3b39bc32);
CAPNP_DECLARE_SCHEMA(e7d8183072ea74aa);
CAPNP_DECLARE_SCHEMA(adde30bdc518106c);
CAPNP_DECLARE_SCHEMA(b865502aff3ab93a);
CAPNP_DECLARE_SCHEMA(87934c0c63ebb108);
CAPNP_DECLARE_SCHEMA(df909ab6846d65af);
CAPNP_DECLARE_SCHEMA(ff5f829257371879);
CAPNP_DECLARE_SCHEMA(e9a3eaaee368bf59);
CAPNP_DECLARE_SCHEMA(d60b1f58294adb30);
CAPNP_DECLARE_SCHEMA(e4315cc04628e715);
CAPNP_DECLARE_SCHEMA(db0f58c2ea8e6040);
CAPNP_DECLARE_SCHEMA(e5f574c1d34a590b);
CAPNP_DECLARE_SCHEMA(8d0b56555e193d45);
CAPNP_DECLARE_SCHEMA(a448d2161985fd79);
CAPNP_DECLARE_SCHEMA(d87bf8710a303f13);
CAPNP_DECLARE_SCHEMA(bc5518654d5cc3c6);
CAPNP_DECLARE_SCHEMA(a348d3e03e3f4093);
CAPNP_DECLARE_SCHEMA(82ffc0f86a8138d4);
CAPNP_DECLARE_SCHEMA(8269bdf6b9bc4bd9);
CAPNP_DECLARE_SCHEMA(9ce1f70941a60179);
CAPNP_DECLARE_SCHEMA(c993b262bb115a8b);
CAPNP_DECLARE_SCHEMA(8859977fa04788fc);
CAPNP_DECLARE_SCHEMA(baf55ed4f5ecb7a1);
CAPNP_DECLARE_SCHEMA(c95208537f30ce0c);
CAPNP_DECLARE_SCHEMA(c3b0f20e0b729180);
CAPNP_DECLARE_SCHEMA(c5856d649d8aa64d);
CAPNP_DECLARE_SCHEMA(d82359f252531ac1);
CAPNP_DECLARE_SCHEMA(d937d331eca87d63);
CAPNP_DECLARE_SCHEMA(8037ead2161585d3);
CAPNP_DECLARE_SCHEMA(f94a83851f75aa98);
CAPNP_DECLARE_SCHEMA(8919cc3851cf18b1);
CAPNP_DECLARE_SCHEMA(c2088ddf5bb0eb33);
CAPNP_DECLARE_SCHEMA(94ae19e7654c460c);
CAPNP_DECLARE_SCHEMA(873f6dd0b87bbcec);
CAPNP_DECLARE_SCHEMA(a46d86a9397498ad);
CAPNP_DECLARE_SCHEMA(a9a8662e05fbf162);
CAPNP_DECLARE_SCHEMA(8c86407fed22d0b0);
CAPNP_DECLARE_SCHEMA(de32d6d021547f17);
CAPNP_DECLARE_SCHEMA(d4066b62f2477ad6);
CAPNP_DECLARE_SCHEMA(f158a40a444c899c);
CAPNP_DECLARE_SCHEMA(9b8e64a917e231a3);
CAPNP_DECLARE_SCHEMA(9fdca1cdde4deae3);
CAPNP_DECLARE_SCHEMA(da8dd87ae137c98b);
CAPNP_DECLARE_SCHEMA(e153d4a4e9f30e5f);
CAPNP_DECLARE_SCHEMA(a0bd9f1b6e0c4f7c);
CAPNP_DECLARE_SCHEMA(ce6ec9c35f65caae);
CAPNP_DECLARE_SCHEMA(94221039dd53ef54);
CAPNP_DECLARE_SCHEMA(956c4f90ee516eee);
CAPNP_DECLARE_SCHEMA(d71b5ef246708eee);
CAPNP_DECLARE_SCHEMA(cb8fb10b78db820e);
CAPNP_DECLARE_SCHEMA(ba59ba03d455df91);
CAPNP_DECLARE_SCHEMA(c1539c57ea27cde6);
CAPNP_DECLARE_SCHEMA(b072c960ca5f7625);
CAPNP_DECLARE_SCHEMA(c5cec7885b2f3ea3);
CAPNP_DECLARE_SCHEMA(ee0cb5af8b3e900b);
CAPNP_DECLARE_SCHEMA(e2fedf5c334cadc0);
CAPNP_DECLARE_SCHEMA(cff33382c4afffd3);
CAPNP_DECLARE_SCHEMA(884376633cef3d3b);
CAPNP_DECLARE_SCHEMA(ce1963c7dc1626fa);
CAPNP_DECLARE_SCHEMA(e4d6685143625397);
CAPNP_DECLARE_SCHEMA(cda0cb5ef01063f2);
CAPNP_DECLARE_SCHEMA(c2b78836578788b8);
CAPNP_DECLARE_SCHEMA(d29ac9ad86ec672d);
CAPNP_DECLARE_SCHEMA(db72cb9687f71d57);
CAPNP_DECLARE_SCHEMA(897dc07075df30ab);
CAPNP_DECLARE_SCHEMA(a022456c769bbab2);
CAPNP_DECLARE_SCHEMA(ba9ebdab2f3d2d64);
CAPNP_DECLARE_SCHEMA(84cc8385c08d8890);
CAPNP_DECLARE_SCHEMA(db0f0f9f862e7eed);
CAPNP_DECLARE_SCHEMA(ac93f434e65216c8);
CAPNP_DECLARE_SCHEMA(f6ec7edb50b5029a);
CAPNP_DECLARE_SCHEMA(bd07b37493258e8e);
CAPNP_DECLARE_SCHEMA(da7878454035ed3a);
CAPNP_DECLARE_SCHEMA(9ff7535744c01c76);
CAPNP_DECLARE_SCHEMA(c71d3c88812151ff);
CAPNP_DECLARE_SCHEMA(bce4509e5983c1e1);
CAPNP_DECLARE_SCHEMA(d531aeddeb5d8e5b);
CAPNP_DECLARE_SCHEMA(9b8d8ad8f1c97f8b);
CAPNP_DECLARE_SCHEMA(e3ea69dc0fbca7d0);
CAPNP_DECLARE_SCHEMA(c9928160e63921ea);
CAPNP_DECLARE_SCHEMA(a323522f0f523a03);
CAPNP_DECLARE_SCHEMA(c0ebffea9176f374);
CAPNP_DECLARE_SCHEMA(9396a7d8e08af448);
CAPNP_DECLARE_SCHEMA(ed3b61df9fb85c6b);
CAPNP_DECLARE_SCHEMA(cf4e977115b9925b);
CAPNP_DECLARE_SCHEMA(f2ffb3198e94899b);
CAPNP_DECLARE_SCHEMA(a26eb0c542495b92);
CAPNP_DECLARE_SCHEMA(c4aa5e5459365fb9);
CAPNP_DECLARE_SCHEMA(9ef3122e0f751d69);
CAPNP_DECLARE_SCHEMA(c05cc21da3828de7);
CAPNP_DECLARE_SCHEMA(f8499b0334710a54);
CAPNP_DECLARE_SCHEMA(e6fab8cdd861ec10);
CAPNP_DECLARE_SCHEMA(d02d57a41aa24cf7);
CAPNP_DECLARE_SCHEMA(a96e5d30df93b43e);
CAPNP_DECLARE_SCHEMA(8536e1edf4aa2e14);

}  // namespace schemas
}  // namespace capnp

namespace vmtsmap {

struct Map {
  Map() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99bfd28ffda77d09, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PtLatLon {
  PtLatLon() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8aa76dc72b09879, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PointType {
  PointType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb4f4dfeeeed3f29, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct BoxType {
  BoxType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a249b85fb5ab8dcc, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PointDataNew {
  PointDataNew() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adc051dcaf5d17ba, 7, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PointDataVector {
  PointDataVector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e871a5fb9f1ab855, 5, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Rect {
  Rect() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8543958636423507, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ClusterParam {
  ClusterParam() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce26efce5dffed46, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Point {
  Point() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0374a1e38e6a0d7, 7, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PointFull {
  PointFull() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b327ba4a3b39bc32, 8, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct TileData {
  TileData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7d8183072ea74aa, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapDetailData {
  MapDetailData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adde30bdc518106c, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Results {
  Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b865502aff3ab93a, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct AnalysisOptions {
  AnalysisOptions() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(87934c0c63ebb108, 6, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ResultType {
  ResultType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df909ab6846d65af, 7, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct NeighboursData {
  NeighboursData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff5f829257371879, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MissingNeighbours {
  MissingNeighbours() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9a3eaaee368bf59, 4, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct OverlapReport {
  OverlapReport() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d60b1f58294adb30, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct OverlapFinalReport {
  OverlapFinalReport() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4315cc04628e715, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MissingNeighbourParam {
  MissingNeighbourParam() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db0f58c2ea8e6040, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct FeederParams {
  FeederParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5f574c1d34a590b, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct CellInfo {
  CellInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8d0b56555e193d45, 9, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct CellDataInfo {
  CellDataInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a448d2161985fd79, 6, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct CellDataExt {
  CellDataExt() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d87bf8710a303f13, 7, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct AddSignalMsg2 {
  AddSignalMsg2() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc5518654d5cc3c6, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct DeleteSignalMsg2 {
  DeleteSignalMsg2() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a348d3e03e3f4093, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct SignalCellExtra {
  SignalCellExtra() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82ffc0f86a8138d4, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct SignalCell {
  SignalCell() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8269bdf6b9bc4bd9, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct SignalCells {
  SignalCells() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ce1f70941a60179, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MetaDataEntry {
  MetaDataEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c993b262bb115a8b, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MetaData {
  MetaData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8859977fa04788fc, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct {
  MapStruct() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct InsertToMapParams;
  struct InsertToMapResults;
  struct GetPointsParams;
  struct GetPointsResults;
  struct InsertPointsInPolygonParams;
  struct InsertPointsInPolygonResults;
  struct AnalyzeParams;
  struct AnalyzeResults;
  struct ReportParams;
  struct ReportResults;
  struct ReportDoneParams;
  struct ReportDoneResults;
  struct QueryPolygonParams;
  struct QueryPolygonResults;
  struct MissingNeiboursParams;
  struct MissingNeiboursResults;
  struct FindMissingNeighboursParams;
  struct FindMissingNeighboursResults;
  struct FindSwappedFeedersParams;
  struct FindSwappedFeedersResults;
  struct NotifyParams;
  struct NotifyResults;
  struct CacheMapParams;
  struct CacheMapResults;
  struct GetPoints2Params;
  struct GetPoints2Results;
  struct QueryPolygon2Params;
  struct QueryPolygon2Results;
  struct GetClusteredPointsParams;
  struct GetClusteredPointsResults;
  struct Analyze2Params;
  struct Analyze2Results;
  struct Report2Params;
  struct Report2Results;
  struct Notify2Params;
  struct Notify2Results;
  struct CacheMap2Params;
  struct CacheMap2Results;
  struct ReportPolyParams;
  struct ReportPolyResults;
  struct ReportPoly2Params;
  struct ReportPoly2Results;
  struct FindMissingNeighbours2Params;
  struct FindMissingNeighbours2Results;
  struct FindSwappedFeeders2Params;
  struct FindSwappedFeeders2Results;
  struct RemoveFromCache2Params;
  struct RemoveFromCache2Results;
  struct ReloadCellsParams;
  struct ReloadCellsResults;
  struct QueryCellsParams;
  struct QueryCellsResults;
  struct InsertSignalParams;
  struct InsertSignalResults;
  struct RemoveSignalParams;
  struct RemoveSignalResults;
  struct OnCellChangeParams;
  struct OnCellChangeResults;
  struct UpdateCellParams;
  struct UpdateCellResults;
  struct FinishUpdateCellParams;
  struct FinishUpdateCellResults;
  struct PingRPCParams;
  struct PingRPCResults;
  struct ToCSVParams;
  struct ToCSVResults;
  struct ExportCellCSVParams;
  struct ExportCellCSVResults;
  struct GenerateParams;
  struct GenerateResults;
  struct GetBoxParams;
  struct GetBoxResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(baf55ed4f5ecb7a1)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct MapStruct::InsertToMapParams {
  InsertToMapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c95208537f30ce0c, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::InsertToMapResults {
  InsertToMapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3b0f20e0b729180, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetPointsParams {
  GetPointsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5856d649d8aa64d, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetPointsResults {
  GetPointsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d82359f252531ac1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::InsertPointsInPolygonParams {
  InsertPointsInPolygonParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d937d331eca87d63, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::InsertPointsInPolygonResults {
  InsertPointsInPolygonResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8037ead2161585d3, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::AnalyzeParams {
  AnalyzeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f94a83851f75aa98, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::AnalyzeResults {
  AnalyzeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8919cc3851cf18b1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportParams {
  ReportParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2088ddf5bb0eb33, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportResults {
  ReportResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94ae19e7654c460c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportDoneParams {
  ReportDoneParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(873f6dd0b87bbcec, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportDoneResults {
  ReportDoneResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a46d86a9397498ad, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryPolygonParams {
  QueryPolygonParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9a8662e05fbf162, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryPolygonResults {
  QueryPolygonResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c86407fed22d0b0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::MissingNeiboursParams {
  MissingNeiboursParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de32d6d021547f17, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::MissingNeiboursResults {
  MissingNeiboursResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4066b62f2477ad6, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindMissingNeighboursParams {
  FindMissingNeighboursParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f158a40a444c899c, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindMissingNeighboursResults {
  FindMissingNeighboursResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b8e64a917e231a3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindSwappedFeedersParams {
  FindSwappedFeedersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9fdca1cdde4deae3, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindSwappedFeedersResults {
  FindSwappedFeedersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da8dd87ae137c98b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::NotifyParams {
  NotifyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e153d4a4e9f30e5f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::NotifyResults {
  NotifyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0bd9f1b6e0c4f7c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::CacheMapParams {
  CacheMapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce6ec9c35f65caae, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::CacheMapResults {
  CacheMapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94221039dd53ef54, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetPoints2Params {
  GetPoints2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(956c4f90ee516eee, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetPoints2Results {
  GetPoints2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d71b5ef246708eee, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryPolygon2Params {
  QueryPolygon2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb8fb10b78db820e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryPolygon2Results {
  QueryPolygon2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba59ba03d455df91, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetClusteredPointsParams {
  GetClusteredPointsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1539c57ea27cde6, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetClusteredPointsResults {
  GetClusteredPointsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b072c960ca5f7625, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Analyze2Params {
  Analyze2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5cec7885b2f3ea3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Analyze2Results {
  Analyze2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee0cb5af8b3e900b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Report2Params {
  Report2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2fedf5c334cadc0, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Report2Results {
  Report2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cff33382c4afffd3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Notify2Params {
  Notify2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(884376633cef3d3b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::Notify2Results {
  Notify2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce1963c7dc1626fa, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::CacheMap2Params {
  CacheMap2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4d6685143625397, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::CacheMap2Results {
  CacheMap2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cda0cb5ef01063f2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportPolyParams {
  ReportPolyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2b78836578788b8, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportPolyResults {
  ReportPolyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d29ac9ad86ec672d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportPoly2Params {
  ReportPoly2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db72cb9687f71d57, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReportPoly2Results {
  ReportPoly2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(897dc07075df30ab, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindMissingNeighbours2Params {
  FindMissingNeighbours2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a022456c769bbab2, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindMissingNeighbours2Results {
  FindMissingNeighbours2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba9ebdab2f3d2d64, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindSwappedFeeders2Params {
  FindSwappedFeeders2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(84cc8385c08d8890, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FindSwappedFeeders2Results {
  FindSwappedFeeders2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db0f0f9f862e7eed, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::RemoveFromCache2Params {
  RemoveFromCache2Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac93f434e65216c8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::RemoveFromCache2Results {
  RemoveFromCache2Results() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f6ec7edb50b5029a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReloadCellsParams {
  ReloadCellsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd07b37493258e8e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ReloadCellsResults {
  ReloadCellsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da7878454035ed3a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryCellsParams {
  QueryCellsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ff7535744c01c76, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::QueryCellsResults {
  QueryCellsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c71d3c88812151ff, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::InsertSignalParams {
  InsertSignalParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bce4509e5983c1e1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::InsertSignalResults {
  InsertSignalResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d531aeddeb5d8e5b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::RemoveSignalParams {
  RemoveSignalParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b8d8ad8f1c97f8b, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::RemoveSignalResults {
  RemoveSignalResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3ea69dc0fbca7d0, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::OnCellChangeParams {
  OnCellChangeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9928160e63921ea, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::OnCellChangeResults {
  OnCellChangeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a323522f0f523a03, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::UpdateCellParams {
  UpdateCellParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0ebffea9176f374, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::UpdateCellResults {
  UpdateCellResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9396a7d8e08af448, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FinishUpdateCellParams {
  FinishUpdateCellParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed3b61df9fb85c6b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::FinishUpdateCellResults {
  FinishUpdateCellResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf4e977115b9925b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::PingRPCParams {
  PingRPCParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f2ffb3198e94899b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::PingRPCResults {
  PingRPCResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a26eb0c542495b92, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ToCSVParams {
  ToCSVParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4aa5e5459365fb9, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ToCSVResults {
  ToCSVResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ef3122e0f751d69, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ExportCellCSVParams {
  ExportCellCSVParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c05cc21da3828de7, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::ExportCellCSVResults {
  ExportCellCSVResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8499b0334710a54, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GenerateParams {
  GenerateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6fab8cdd861ec10, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GenerateResults {
  GenerateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d02d57a41aa24cf7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetBoxParams {
  GetBoxParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a96e5d30df93b43e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MapStruct::GetBoxResults {
  GetBoxResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8536e1edf4aa2e14, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Map::Reader {
public:
  typedef Map Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCampaingID() const;

  inline bool hasProvinceCode() const;
  inline  ::capnp::Text::Reader getProvinceCode() const;

  inline  ::int64_t getStartTime() const;

  inline  ::int64_t getStopTime() const;

  inline bool hasDeviceList() const;
  inline  ::capnp::List< ::int32_t>::Reader getDeviceList() const;

  inline  ::uint8_t getType() const;

  inline  ::int8_t getIndoor() const;

  inline  ::int8_t getUeposition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Map::Builder {
public:
  typedef Map Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCampaingID();
  inline void setCampaingID( ::uint32_t value);

  inline bool hasProvinceCode();
  inline  ::capnp::Text::Builder getProvinceCode();
  inline void setProvinceCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initProvinceCode(unsigned int size);
  inline void adoptProvinceCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownProvinceCode();

  inline  ::int64_t getStartTime();
  inline void setStartTime( ::int64_t value);

  inline  ::int64_t getStopTime();
  inline void setStopTime( ::int64_t value);

  inline bool hasDeviceList();
  inline  ::capnp::List< ::int32_t>::Builder getDeviceList();
  inline void setDeviceList( ::capnp::List< ::int32_t>::Reader value);
  inline void setDeviceList(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initDeviceList(unsigned int size);
  inline void adoptDeviceList(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownDeviceList();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int8_t getIndoor();
  inline void setIndoor( ::int8_t value);

  inline  ::int8_t getUeposition();
  inline void setUeposition( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Map::Pipeline {
public:
  typedef Map Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PtLatLon::Reader {
public:
  typedef PtLatLon Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getX() const;

  inline  ::int64_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PtLatLon::Builder {
public:
  typedef PtLatLon Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getX();
  inline void setX( ::int64_t value);

  inline  ::int64_t getY();
  inline void setY( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PtLatLon::Pipeline {
public:
  typedef PtLatLon Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PointType::Reader {
public:
  typedef PointType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PointType::Builder {
public:
  typedef PointType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PointType::Pipeline {
public:
  typedef PointType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BoxType::Reader {
public:
  typedef BoxType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getTopLat() const;

  inline double getBottomLat() const;

  inline double getTopLng() const;

  inline double getBottomLng() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BoxType::Builder {
public:
  typedef BoxType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getTopLat();
  inline void setTopLat(double value);

  inline double getBottomLat();
  inline void setBottomLat(double value);

  inline double getTopLng();
  inline void setTopLng(double value);

  inline double getBottomLng();
  inline void setBottomLng(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BoxType::Pipeline {
public:
  typedef BoxType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PointDataNew::Reader {
public:
  typedef PointDataNew Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getLat() const;

  inline double getLon() const;

  inline  ::int64_t getDatetime() const;

  inline  ::uint32_t getId() const;

  inline  ::int32_t getDevice() const;

  inline  ::uint32_t getCellID() const;

  inline  ::int32_t getRfcn() const;

  inline  ::int16_t getRscpRssi() const;

  inline  ::int8_t getEcno() const;

  inline  ::int8_t getCOverImin() const;

  inline  ::int8_t getCOverImax() const;

  inline  ::int8_t getCOverIavg() const;

  inline bool getIndoor() const;

  inline  ::uint8_t getEventID() const;

  inline  ::int8_t getRxqual() const;

  inline  ::uint8_t getType() const;

  inline  ::int8_t getUeposition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PointDataNew::Builder {
public:
  typedef PointDataNew Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLat();
  inline void setLat(double value);

  inline double getLon();
  inline void setLon(double value);

  inline  ::int64_t getDatetime();
  inline void setDatetime( ::int64_t value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::int32_t getDevice();
  inline void setDevice( ::int32_t value);

  inline  ::uint32_t getCellID();
  inline void setCellID( ::uint32_t value);

  inline  ::int32_t getRfcn();
  inline void setRfcn( ::int32_t value);

  inline  ::int16_t getRscpRssi();
  inline void setRscpRssi( ::int16_t value);

  inline  ::int8_t getEcno();
  inline void setEcno( ::int8_t value);

  inline  ::int8_t getCOverImin();
  inline void setCOverImin( ::int8_t value);

  inline  ::int8_t getCOverImax();
  inline void setCOverImax( ::int8_t value);

  inline  ::int8_t getCOverIavg();
  inline void setCOverIavg( ::int8_t value);

  inline bool getIndoor();
  inline void setIndoor(bool value);

  inline  ::uint8_t getEventID();
  inline void setEventID( ::uint8_t value);

  inline  ::int8_t getRxqual();
  inline void setRxqual( ::int8_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int8_t getUeposition();
  inline void setUeposition( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PointDataNew::Pipeline {
public:
  typedef PointDataNew Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PointDataVector::Reader {
public:
  typedef PointDataVector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::PointDataNew>::Reader getData() const;

  inline  ::int32_t getNumPoints() const;

  inline  ::uint32_t getCampaignID() const;

  inline bool hasProvinceCode() const;
  inline  ::capnp::Text::Reader getProvinceCode() const;

  inline  ::int64_t getStartTime() const;

  inline  ::int64_t getStopTime() const;

  inline bool hasDeviceList() const;
  inline  ::capnp::List< ::int32_t>::Reader getDeviceList() const;

  inline  ::uint8_t getType() const;

  inline  ::int32_t getMaxID() const;

  inline  ::int32_t getTotalPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PointDataVector::Builder {
public:
  typedef PointDataVector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::PointDataNew>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::PointDataNew>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointDataNew>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointDataNew>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointDataNew>> disownData();

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline  ::uint32_t getCampaignID();
  inline void setCampaignID( ::uint32_t value);

  inline bool hasProvinceCode();
  inline  ::capnp::Text::Builder getProvinceCode();
  inline void setProvinceCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initProvinceCode(unsigned int size);
  inline void adoptProvinceCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownProvinceCode();

  inline  ::int64_t getStartTime();
  inline void setStartTime( ::int64_t value);

  inline  ::int64_t getStopTime();
  inline void setStopTime( ::int64_t value);

  inline bool hasDeviceList();
  inline  ::capnp::List< ::int32_t>::Builder getDeviceList();
  inline void setDeviceList( ::capnp::List< ::int32_t>::Reader value);
  inline void setDeviceList(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initDeviceList(unsigned int size);
  inline void adoptDeviceList(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownDeviceList();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int32_t getMaxID();
  inline void setMaxID( ::int32_t value);

  inline  ::int32_t getTotalPoints();
  inline void setTotalPoints( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PointDataVector::Pipeline {
public:
  typedef PointDataVector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Rect::Reader {
public:
  typedef Rect Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getTopLat() const;

  inline  ::int64_t getBottomLat() const;

  inline  ::int64_t getTopLng() const;

  inline  ::int64_t getBottomLng() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Rect::Builder {
public:
  typedef Rect Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getTopLat();
  inline void setTopLat( ::int64_t value);

  inline  ::int64_t getBottomLat();
  inline void setBottomLat( ::int64_t value);

  inline  ::int64_t getTopLng();
  inline void setTopLng( ::int64_t value);

  inline  ::int64_t getBottomLng();
  inline void setBottomLng( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Rect::Pipeline {
public:
  typedef Rect Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ClusterParam::Reader {
public:
  typedef ClusterParam Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getFilterType() const;

  inline  ::int32_t getZoomLevel() const;

  inline float getViewPercentW() const;

  inline float getViewPercentH() const;

  inline  ::int32_t getMapWidthPx() const;

  inline  ::int32_t getMapHeightPx() const;

  inline  ::int32_t getPointLimit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ClusterParam::Builder {
public:
  typedef ClusterParam Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getFilterType();
  inline void setFilterType( ::int32_t value);

  inline  ::int32_t getZoomLevel();
  inline void setZoomLevel( ::int32_t value);

  inline float getViewPercentW();
  inline void setViewPercentW(float value);

  inline float getViewPercentH();
  inline void setViewPercentH(float value);

  inline  ::int32_t getMapWidthPx();
  inline void setMapWidthPx( ::int32_t value);

  inline  ::int32_t getMapHeightPx();
  inline void setMapHeightPx( ::int32_t value);

  inline  ::int32_t getPointLimit();
  inline void setPointLimit( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ClusterParam::Pipeline {
public:
  typedef ClusterParam Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point::Reader {
public:
  typedef Point Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId() const;

  inline  ::uint8_t getType() const;

  inline  ::int64_t getLat() const;

  inline  ::int64_t getLon() const;

  inline  ::int16_t getRscpRssi() const;

  inline  ::int16_t getEcno() const;

  inline  ::int16_t getCOverImin() const;

  inline  ::int16_t getCOverImax() const;

  inline  ::int64_t getDatetime() const;

  inline  ::int32_t getDevice() const;

  inline bool getIndoor() const;

  inline  ::uint8_t getEventID() const;

  inline  ::int32_t getCellID() const;

  inline  ::int16_t getRxqual() const;

  inline  ::int16_t getCOverIavg() const;

  inline  ::int32_t getRfcn() const;

  inline  ::int8_t getUeposition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point::Builder {
public:
  typedef Point Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int64_t getLat();
  inline void setLat( ::int64_t value);

  inline  ::int64_t getLon();
  inline void setLon( ::int64_t value);

  inline  ::int16_t getRscpRssi();
  inline void setRscpRssi( ::int16_t value);

  inline  ::int16_t getEcno();
  inline void setEcno( ::int16_t value);

  inline  ::int16_t getCOverImin();
  inline void setCOverImin( ::int16_t value);

  inline  ::int16_t getCOverImax();
  inline void setCOverImax( ::int16_t value);

  inline  ::int64_t getDatetime();
  inline void setDatetime( ::int64_t value);

  inline  ::int32_t getDevice();
  inline void setDevice( ::int32_t value);

  inline bool getIndoor();
  inline void setIndoor(bool value);

  inline  ::uint8_t getEventID();
  inline void setEventID( ::uint8_t value);

  inline  ::int32_t getCellID();
  inline void setCellID( ::int32_t value);

  inline  ::int16_t getRxqual();
  inline void setRxqual( ::int16_t value);

  inline  ::int16_t getCOverIavg();
  inline void setCOverIavg( ::int16_t value);

  inline  ::int32_t getRfcn();
  inline void setRfcn( ::int32_t value);

  inline  ::int8_t getUeposition();
  inline void setUeposition( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point::Pipeline {
public:
  typedef Point Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PointFull::Reader {
public:
  typedef PointFull Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getLat() const;

  inline double getLon() const;

  inline  ::int64_t getDatetime() const;

  inline  ::uint32_t getId() const;

  inline  ::int32_t getDevice() const;

  inline  ::int32_t getCellID() const;

  inline  ::int32_t getRfcn() const;

  inline  ::uint8_t getType() const;

  inline  ::int16_t getRscpRssi() const;

  inline  ::int8_t getEcno() const;

  inline  ::int8_t getCOverImin() const;

  inline  ::int8_t getCOverImax() const;

  inline  ::int8_t getCOverIavg() const;

  inline  ::uint8_t getEventID() const;

  inline  ::int8_t getRxqual() const;

  inline  ::int8_t getRxlev1() const;

  inline  ::int8_t getRxlev2() const;

  inline  ::int8_t getRxlev3() const;

  inline  ::int8_t getRxlev4() const;

  inline  ::int8_t getRxlev5() const;

  inline  ::int8_t getRxlev6() const;

  inline  ::int8_t getUeposition() const;

  inline bool getIndoor() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PointFull::Builder {
public:
  typedef PointFull Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLat();
  inline void setLat(double value);

  inline double getLon();
  inline void setLon(double value);

  inline  ::int64_t getDatetime();
  inline void setDatetime( ::int64_t value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::int32_t getDevice();
  inline void setDevice( ::int32_t value);

  inline  ::int32_t getCellID();
  inline void setCellID( ::int32_t value);

  inline  ::int32_t getRfcn();
  inline void setRfcn( ::int32_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int16_t getRscpRssi();
  inline void setRscpRssi( ::int16_t value);

  inline  ::int8_t getEcno();
  inline void setEcno( ::int8_t value);

  inline  ::int8_t getCOverImin();
  inline void setCOverImin( ::int8_t value);

  inline  ::int8_t getCOverImax();
  inline void setCOverImax( ::int8_t value);

  inline  ::int8_t getCOverIavg();
  inline void setCOverIavg( ::int8_t value);

  inline  ::uint8_t getEventID();
  inline void setEventID( ::uint8_t value);

  inline  ::int8_t getRxqual();
  inline void setRxqual( ::int8_t value);

  inline  ::int8_t getRxlev1();
  inline void setRxlev1( ::int8_t value);

  inline  ::int8_t getRxlev2();
  inline void setRxlev2( ::int8_t value);

  inline  ::int8_t getRxlev3();
  inline void setRxlev3( ::int8_t value);

  inline  ::int8_t getRxlev4();
  inline void setRxlev4( ::int8_t value);

  inline  ::int8_t getRxlev5();
  inline void setRxlev5( ::int8_t value);

  inline  ::int8_t getRxlev6();
  inline void setRxlev6( ::int8_t value);

  inline  ::int8_t getUeposition();
  inline void setUeposition( ::int8_t value);

  inline bool getIndoor();
  inline void setIndoor(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PointFull::Pipeline {
public:
  typedef PointFull Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TileData::Reader {
public:
  typedef TileData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasData2G() const;
  inline  ::capnp::List< ::vmtsmap::PointFull>::Reader getData2G() const;

  inline bool hasData3G() const;
  inline  ::capnp::List< ::vmtsmap::PointFull>::Reader getData3G() const;

  inline bool hasBb() const;
  inline  ::vmtsmap::BoxType::Reader getBb() const;

  inline  ::int32_t getNumPoints() const;

  inline  ::int32_t getMaxId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TileData::Builder {
public:
  typedef TileData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData2G();
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder getData2G();
  inline void setData2G( ::capnp::List< ::vmtsmap::PointFull>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder initData2G(unsigned int size);
  inline void adoptData2G(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> disownData2G();

  inline bool hasData3G();
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder getData3G();
  inline void setData3G( ::capnp::List< ::vmtsmap::PointFull>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder initData3G(unsigned int size);
  inline void adoptData3G(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> disownData3G();

  inline bool hasBb();
  inline  ::vmtsmap::BoxType::Builder getBb();
  inline void setBb( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBb();
  inline void adoptBb(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBb();

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline  ::int32_t getMaxId();
  inline void setMaxId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TileData::Pipeline {
public:
  typedef TileData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getBb();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapDetailData::Reader {
public:
  typedef MapDetailData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasBb() const;
  inline  ::vmtsmap::BoxType::Reader getBb() const;

  inline  ::int32_t getNumPoints() const;

  inline  ::int32_t getMaxId() const;

  inline  ::int8_t getNumTiles() const;

  inline double getLx() const;

  inline double getLy() const;

  inline  ::int8_t getNROWS() const;

  inline  ::int8_t getNCOLS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapDetailData::Builder {
public:
  typedef MapDetailData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBb();
  inline  ::vmtsmap::BoxType::Builder getBb();
  inline void setBb( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBb();
  inline void adoptBb(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBb();

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline  ::int32_t getMaxId();
  inline void setMaxId( ::int32_t value);

  inline  ::int8_t getNumTiles();
  inline void setNumTiles( ::int8_t value);

  inline double getLx();
  inline void setLx(double value);

  inline double getLy();
  inline void setLy(double value);

  inline  ::int8_t getNROWS();
  inline void setNROWS( ::int8_t value);

  inline  ::int8_t getNCOLS();
  inline void setNCOLS( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapDetailData::Pipeline {
public:
  typedef MapDetailData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getBb();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Results::Reader {
public:
  typedef Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getData() const;

  inline bool hasRemains() const;
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader getRemains() const;

  inline bool getLoaded() const;

  inline  ::int32_t getNumPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Results::Builder {
public:
  typedef Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownData();

  inline bool hasRemains();
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder getRemains();
  inline void setRemains( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value);
  inline void setRemains(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder initRemains(unsigned int size);
  inline void adoptRemains(::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> disownRemains();

  inline bool getLoaded();
  inline void setLoaded(bool value);

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Results::Pipeline {
public:
  typedef Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AnalysisOptions::Reader {
public:
  typedef AnalysisOptions Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline float getEps() const;

  inline float getMinP() const;

  inline  ::int16_t getDbmThreshold() const;

  inline  ::int16_t getRssiThreshold() const;

  inline  ::int16_t getEcnoThreshold() const;

  inline  ::int64_t getLx() const;

  inline  ::int64_t getLy() const;

  inline  ::int8_t getAnalysisType() const;

  inline  ::int32_t getOv2G() const;

  inline  ::int32_t getOv3G() const;

  inline  ::uint8_t getDataType() const;

  inline  ::int32_t getMinPts() const;

  inline  ::uint8_t getOvExtra() const;

  inline  ::int16_t getRxqualThreshold() const;

  inline bool getViewExtra() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AnalysisOptions::Builder {
public:
  typedef AnalysisOptions Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getEps();
  inline void setEps(float value);

  inline float getMinP();
  inline void setMinP(float value);

  inline  ::int16_t getDbmThreshold();
  inline void setDbmThreshold( ::int16_t value);

  inline  ::int16_t getRssiThreshold();
  inline void setRssiThreshold( ::int16_t value);

  inline  ::int16_t getEcnoThreshold();
  inline void setEcnoThreshold( ::int16_t value);

  inline  ::int64_t getLx();
  inline void setLx( ::int64_t value);

  inline  ::int64_t getLy();
  inline void setLy( ::int64_t value);

  inline  ::int8_t getAnalysisType();
  inline void setAnalysisType( ::int8_t value);

  inline  ::int32_t getOv2G();
  inline void setOv2G( ::int32_t value);

  inline  ::int32_t getOv3G();
  inline void setOv3G( ::int32_t value);

  inline  ::uint8_t getDataType();
  inline void setDataType( ::uint8_t value);

  inline  ::int32_t getMinPts();
  inline void setMinPts( ::int32_t value);

  inline  ::uint8_t getOvExtra();
  inline void setOvExtra( ::uint8_t value);

  inline  ::int16_t getRxqualThreshold();
  inline void setRxqualThreshold( ::int16_t value);

  inline bool getViewExtra();
  inline void setViewExtra(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AnalysisOptions::Pipeline {
public:
  typedef AnalysisOptions Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ResultType::Reader {
public:
  typedef ResultType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getArea() const;

  inline  ::int32_t getNumPoints() const;

  inline double getCentroidx() const;

  inline double getCentroidy() const;

  inline double getRadius() const;

  inline  ::int32_t getTotalPoints() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader getData() const;

  inline  ::uint8_t getType() const;

  inline  ::uint8_t getDataType() const;

  inline  ::int32_t getMaxID() const;

  inline  ::int32_t getMapNumPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ResultType::Builder {
public:
  typedef ResultType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getArea();
  inline void setArea(double value);

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline double getCentroidx();
  inline void setCentroidx(double value);

  inline double getCentroidy();
  inline void setCentroidy(double value);

  inline double getRadius();
  inline void setRadius(double value);

  inline  ::int32_t getTotalPoints();
  inline void setTotalPoints( ::int32_t value);

  inline bool hasData();
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder getData();
  inline void setData( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> disownData();

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::uint8_t getDataType();
  inline void setDataType( ::uint8_t value);

  inline  ::int32_t getMaxID();
  inline void setMaxID( ::int32_t value);

  inline  ::int32_t getMapNumPoints();
  inline void setMapNumPoints( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ResultType::Pipeline {
public:
  typedef ResultType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NeighboursData::Reader {
public:
  typedef NeighboursData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasCellCode() const;
  inline  ::capnp::Text::Reader getCellCode() const;

  inline  ::int32_t getCount() const;

  inline  ::int32_t getTotals() const;

  inline float getPercent() const;

  inline double getLat() const;

  inline double getLon() const;

  inline  ::int16_t getAzimuth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NeighboursData::Builder {
public:
  typedef NeighboursData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCellCode();
  inline  ::capnp::Text::Builder getCellCode();
  inline void setCellCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCellCode(unsigned int size);
  inline void adoptCellCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCellCode();

  inline  ::int32_t getCount();
  inline void setCount( ::int32_t value);

  inline  ::int32_t getTotals();
  inline void setTotals( ::int32_t value);

  inline float getPercent();
  inline void setPercent(float value);

  inline double getLat();
  inline void setLat(double value);

  inline double getLon();
  inline void setLon(double value);

  inline  ::int16_t getAzimuth();
  inline void setAzimuth( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NeighboursData::Pipeline {
public:
  typedef NeighboursData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MissingNeighbours::Reader {
public:
  typedef MissingNeighbours Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasServing() const;
  inline  ::capnp::Text::Reader getServing() const;

  inline bool hasMissing() const;
  inline  ::capnp::List< ::vmtsmap::NeighboursData>::Reader getMissing() const;

  inline double getLat() const;

  inline double getLon() const;

  inline  ::int16_t getAzimuth() const;

  inline  ::int8_t getType() const;

  inline  ::int32_t getMaxID() const;

  inline  ::int32_t getMapNumPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MissingNeighbours::Builder {
public:
  typedef MissingNeighbours Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasServing();
  inline  ::capnp::Text::Builder getServing();
  inline void setServing( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initServing(unsigned int size);
  inline void adoptServing(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownServing();

  inline bool hasMissing();
  inline  ::capnp::List< ::vmtsmap::NeighboursData>::Builder getMissing();
  inline void setMissing( ::capnp::List< ::vmtsmap::NeighboursData>::Reader value);
  inline  ::capnp::List< ::vmtsmap::NeighboursData>::Builder initMissing(unsigned int size);
  inline void adoptMissing(::capnp::Orphan< ::capnp::List< ::vmtsmap::NeighboursData>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::NeighboursData>> disownMissing();

  inline double getLat();
  inline void setLat(double value);

  inline double getLon();
  inline void setLon(double value);

  inline  ::int16_t getAzimuth();
  inline void setAzimuth( ::int16_t value);

  inline  ::int8_t getType();
  inline void setType( ::int8_t value);

  inline  ::int32_t getMaxID();
  inline void setMaxID( ::int32_t value);

  inline  ::int32_t getMapNumPoints();
  inline void setMapNumPoints( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MissingNeighbours::Pipeline {
public:
  typedef MissingNeighbours Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OverlapReport::Reader {
public:
  typedef OverlapReport Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getNumCells() const;

  inline float getPercent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OverlapReport::Builder {
public:
  typedef OverlapReport Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getNumCells();
  inline void setNumCells( ::int32_t value);

  inline float getPercent();
  inline void setPercent(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OverlapReport::Pipeline {
public:
  typedef OverlapReport Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OverlapFinalReport::Reader {
public:
  typedef OverlapFinalReport Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasReport2G() const;
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader getReport2G() const;

  inline bool hasReport3G() const;
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader getReport3G() const;

  inline  ::int32_t getCampaignID() const;

  inline bool hasProvinceCode() const;
  inline  ::capnp::Text::Reader getProvinceCode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OverlapFinalReport::Builder {
public:
  typedef OverlapFinalReport Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasReport2G();
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder getReport2G();
  inline void setReport2G( ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader value);
  inline void setReport2G(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::OverlapReport>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder initReport2G(unsigned int size);
  inline void adoptReport2G(::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>> disownReport2G();

  inline bool hasReport3G();
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder getReport3G();
  inline void setReport3G( ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader value);
  inline void setReport3G(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::OverlapReport>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder initReport3G(unsigned int size);
  inline void adoptReport3G(::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>> disownReport3G();

  inline  ::int32_t getCampaignID();
  inline void setCampaignID( ::int32_t value);

  inline bool hasProvinceCode();
  inline  ::capnp::Text::Builder getProvinceCode();
  inline void setProvinceCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initProvinceCode(unsigned int size);
  inline void adoptProvinceCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownProvinceCode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OverlapFinalReport::Pipeline {
public:
  typedef OverlapFinalReport Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MissingNeighbourParam::Reader {
public:
  typedef MissingNeighbourParam Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline float getRSearch() const;

  inline float getMinOF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MissingNeighbourParam::Builder {
public:
  typedef MissingNeighbourParam Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getRSearch();
  inline void setRSearch(float value);

  inline float getMinOF();
  inline void setMinOF(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MissingNeighbourParam::Pipeline {
public:
  typedef MissingNeighbourParam Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FeederParams::Reader {
public:
  typedef FeederParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getMinStrength2G() const;

  inline  ::int16_t getMinStrength3G() const;

  inline  ::int16_t getMinPts() const;

  inline float getMinR() const;

  inline float getMinP() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FeederParams::Builder {
public:
  typedef FeederParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getMinStrength2G();
  inline void setMinStrength2G( ::int16_t value);

  inline  ::int16_t getMinStrength3G();
  inline void setMinStrength3G( ::int16_t value);

  inline  ::int16_t getMinPts();
  inline void setMinPts( ::int16_t value);

  inline float getMinR();
  inline void setMinR(float value);

  inline float getMinP();
  inline void setMinP(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FeederParams::Pipeline {
public:
  typedef FeederParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellInfo::Reader {
public:
  typedef CellInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasNeighbors() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getNeighbors() const;

  inline bool hasCellCode() const;
  inline  ::capnp::Text::Reader getCellCode() const;

  inline double getLat() const;

  inline double getLng() const;

  inline float getPercent() const;

  inline float getTilt() const;

  inline float getAntennaHeightGround() const;

  inline  ::int32_t getTotal() const;

  inline  ::int16_t getAzimuth() const;

  inline  ::int32_t getCi() const;

  inline  ::int32_t getLac() const;

  inline  ::int32_t getBcch() const;

  inline  ::int32_t getPscBsic() const;

  inline  ::uint8_t getType() const;

  inline double getVoiceTraffic() const;

  inline double getDataTraffic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellInfo::Builder {
public:
  typedef CellInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNeighbors();
  inline  ::capnp::List< ::capnp::Text>::Builder getNeighbors();
  inline void setNeighbors( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setNeighbors(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initNeighbors(unsigned int size);
  inline void adoptNeighbors(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownNeighbors();

  inline bool hasCellCode();
  inline  ::capnp::Text::Builder getCellCode();
  inline void setCellCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCellCode(unsigned int size);
  inline void adoptCellCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCellCode();

  inline double getLat();
  inline void setLat(double value);

  inline double getLng();
  inline void setLng(double value);

  inline float getPercent();
  inline void setPercent(float value);

  inline float getTilt();
  inline void setTilt(float value);

  inline float getAntennaHeightGround();
  inline void setAntennaHeightGround(float value);

  inline  ::int32_t getTotal();
  inline void setTotal( ::int32_t value);

  inline  ::int16_t getAzimuth();
  inline void setAzimuth( ::int16_t value);

  inline  ::int32_t getCi();
  inline void setCi( ::int32_t value);

  inline  ::int32_t getLac();
  inline void setLac( ::int32_t value);

  inline  ::int32_t getBcch();
  inline void setBcch( ::int32_t value);

  inline  ::int32_t getPscBsic();
  inline void setPscBsic( ::int32_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline double getVoiceTraffic();
  inline void setVoiceTraffic(double value);

  inline double getDataTraffic();
  inline void setDataTraffic(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellInfo::Pipeline {
public:
  typedef CellInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellDataInfo::Reader {
public:
  typedef CellDataInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasRelations() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getRelations() const;

  inline bool hasCellName() const;
  inline  ::capnp::Text::Reader getCellName() const;

  inline double getLat() const;

  inline double getLng() const;

  inline  ::int32_t getCi() const;

  inline  ::int16_t getAzimuth() const;

  inline  ::uint8_t getType() const;

  inline  ::int32_t getCellId() const;

  inline  ::int32_t getStationHouseId() const;

  inline bool hasStationCode() const;
  inline  ::capnp::Text::Reader getStationCode() const;

  inline double getVoiceTraffic() const;

  inline double getDataTraffic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellDataInfo::Builder {
public:
  typedef CellDataInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRelations();
  inline  ::capnp::List< ::capnp::Text>::Builder getRelations();
  inline void setRelations( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setRelations(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initRelations(unsigned int size);
  inline void adoptRelations(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownRelations();

  inline bool hasCellName();
  inline  ::capnp::Text::Builder getCellName();
  inline void setCellName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCellName(unsigned int size);
  inline void adoptCellName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCellName();

  inline double getLat();
  inline void setLat(double value);

  inline double getLng();
  inline void setLng(double value);

  inline  ::int32_t getCi();
  inline void setCi( ::int32_t value);

  inline  ::int16_t getAzimuth();
  inline void setAzimuth( ::int16_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline  ::int32_t getCellId();
  inline void setCellId( ::int32_t value);

  inline  ::int32_t getStationHouseId();
  inline void setStationHouseId( ::int32_t value);

  inline bool hasStationCode();
  inline  ::capnp::Text::Builder getStationCode();
  inline void setStationCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStationCode(unsigned int size);
  inline void adoptStationCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStationCode();

  inline double getVoiceTraffic();
  inline void setVoiceTraffic(double value);

  inline double getDataTraffic();
  inline void setDataTraffic(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellDataInfo::Pipeline {
public:
  typedef CellDataInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellDataExt::Reader {
public:
  typedef CellDataExt Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMyRelations() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getMyRelations() const;

  inline bool hasStationCode() const;
  inline  ::capnp::Text::Reader getStationCode() const;

  inline double getLat() const;

  inline double getLng() const;

  inline  ::int32_t getCi() const;

  inline  ::int32_t getCellId() const;

  inline  ::int32_t getStationHouseId() const;

  inline float getAntennaHeightGround() const;

  inline float getTilt() const;

  inline  ::int32_t getBcch() const;

  inline  ::int32_t getLac() const;

  inline  ::int32_t getPscBsic() const;

  inline  ::int16_t getAzimuth() const;

  inline  ::uint8_t getType() const;

  inline bool hasCode() const;
  inline  ::capnp::Text::Reader getCode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellDataExt::Builder {
public:
  typedef CellDataExt Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMyRelations();
  inline  ::capnp::List< ::capnp::Text>::Builder getMyRelations();
  inline void setMyRelations( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setMyRelations(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initMyRelations(unsigned int size);
  inline void adoptMyRelations(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownMyRelations();

  inline bool hasStationCode();
  inline  ::capnp::Text::Builder getStationCode();
  inline void setStationCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStationCode(unsigned int size);
  inline void adoptStationCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStationCode();

  inline double getLat();
  inline void setLat(double value);

  inline double getLng();
  inline void setLng(double value);

  inline  ::int32_t getCi();
  inline void setCi( ::int32_t value);

  inline  ::int32_t getCellId();
  inline void setCellId( ::int32_t value);

  inline  ::int32_t getStationHouseId();
  inline void setStationHouseId( ::int32_t value);

  inline float getAntennaHeightGround();
  inline void setAntennaHeightGround(float value);

  inline float getTilt();
  inline void setTilt(float value);

  inline  ::int32_t getBcch();
  inline void setBcch( ::int32_t value);

  inline  ::int32_t getLac();
  inline void setLac( ::int32_t value);

  inline  ::int32_t getPscBsic();
  inline void setPscBsic( ::int32_t value);

  inline  ::int16_t getAzimuth();
  inline void setAzimuth( ::int16_t value);

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline bool hasCode();
  inline  ::capnp::Text::Builder getCode();
  inline void setCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCode(unsigned int size);
  inline void adoptCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellDataExt::Pipeline {
public:
  typedef CellDataExt Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AddSignalMsg2::Reader {
public:
  typedef AddSignalMsg2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCampaignID() const;

  inline bool hasProvinceCode() const;
  inline  ::capnp::Text::Reader getProvinceCode() const;

  inline  ::uint32_t getStartId() const;

  inline bool hasRows() const;
  inline  ::capnp::List< ::vmtsmap::PointFull>::Reader getRows() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AddSignalMsg2::Builder {
public:
  typedef AddSignalMsg2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCampaignID();
  inline void setCampaignID( ::uint32_t value);

  inline bool hasProvinceCode();
  inline  ::capnp::Text::Builder getProvinceCode();
  inline void setProvinceCode( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initProvinceCode(unsigned int size);
  inline void adoptProvinceCode(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownProvinceCode();

  inline  ::uint32_t getStartId();
  inline void setStartId( ::uint32_t value);

  inline bool hasRows();
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder getRows();
  inline void setRows( ::capnp::List< ::vmtsmap::PointFull>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder initRows(unsigned int size);
  inline void adoptRows(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> disownRows();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AddSignalMsg2::Pipeline {
public:
  typedef AddSignalMsg2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DeleteSignalMsg2::Reader {
public:
  typedef DeleteSignalMsg2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPoly() const;
  inline  ::capnp::List< ::vmtsmap::PointType>::Reader getPoly() const;

  inline bool hasVDeleted() const;
  inline  ::capnp::List< ::uint32_t>::Reader getVDeleted() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DeleteSignalMsg2::Builder {
public:
  typedef DeleteSignalMsg2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoly();
  inline  ::capnp::List< ::vmtsmap::PointType>::Builder getPoly();
  inline void setPoly( ::capnp::List< ::vmtsmap::PointType>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointType>::Builder initPoly(unsigned int size);
  inline void adoptPoly(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>> disownPoly();

  inline bool hasVDeleted();
  inline  ::capnp::List< ::uint32_t>::Builder getVDeleted();
  inline void setVDeleted( ::capnp::List< ::uint32_t>::Reader value);
  inline void setVDeleted(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initVDeleted(unsigned int size);
  inline void adoptVDeleted(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownVDeleted();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DeleteSignalMsg2::Pipeline {
public:
  typedef DeleteSignalMsg2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SignalCellExtra::Reader {
public:
  typedef SignalCellExtra Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBsic() const;

  inline  ::int32_t getLac() const;

  inline  ::int32_t getArfcn() const;

  inline  ::int32_t getCirnc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SignalCellExtra::Builder {
public:
  typedef SignalCellExtra Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBsic();
  inline void setBsic( ::int32_t value);

  inline  ::int32_t getLac();
  inline void setLac( ::int32_t value);

  inline  ::int32_t getArfcn();
  inline void setArfcn( ::int32_t value);

  inline  ::int32_t getCirnc();
  inline void setCirnc( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SignalCellExtra::Pipeline {
public:
  typedef SignalCellExtra Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SignalCell::Reader {
public:
  typedef SignalCell Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline double getLat() const;

  inline double getLng() const;

  inline  ::int32_t getSc() const;

  inline  ::int32_t getLac() const;

  inline  ::int32_t getCirnc() const;

  inline  ::int32_t getRfcn() const;

  inline bool hasNbData() const;
  inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Reader getNbData() const;

  inline  ::int8_t getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SignalCell::Builder {
public:
  typedef SignalCell Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline double getLat();
  inline void setLat(double value);

  inline double getLng();
  inline void setLng(double value);

  inline  ::int32_t getSc();
  inline void setSc( ::int32_t value);

  inline  ::int32_t getLac();
  inline void setLac( ::int32_t value);

  inline  ::int32_t getCirnc();
  inline void setCirnc( ::int32_t value);

  inline  ::int32_t getRfcn();
  inline void setRfcn( ::int32_t value);

  inline bool hasNbData();
  inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Builder getNbData();
  inline void setNbData( ::capnp::List< ::vmtsmap::SignalCellExtra>::Reader value);
  inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Builder initNbData(unsigned int size);
  inline void adoptNbData(::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCellExtra>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCellExtra>> disownNbData();

  inline  ::int8_t getType();
  inline void setType( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SignalCell::Pipeline {
public:
  typedef SignalCell Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SignalCells::Reader {
public:
  typedef SignalCells Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getNumPoints() const;

  inline  ::int32_t getMaxId() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::SignalCell>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SignalCells::Builder {
public:
  typedef SignalCells Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline  ::int32_t getMaxId();
  inline void setMaxId( ::int32_t value);

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::SignalCell>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::SignalCell>::Reader value);
  inline  ::capnp::List< ::vmtsmap::SignalCell>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCell>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCell>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SignalCells::Pipeline {
public:
  typedef SignalCells Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MetaDataEntry::Reader {
public:
  typedef MetaDataEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getTopLat() const;

  inline double getBottomLat() const;

  inline double getTopLng() const;

  inline double getBottomLng() const;

  inline  ::int32_t getNumPoints() const;

  inline bool hasFilename() const;
  inline  ::capnp::Text::Reader getFilename() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MetaDataEntry::Builder {
public:
  typedef MetaDataEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getTopLat();
  inline void setTopLat(double value);

  inline double getBottomLat();
  inline void setBottomLat(double value);

  inline double getTopLng();
  inline void setTopLng(double value);

  inline double getBottomLng();
  inline void setBottomLng(double value);

  inline  ::int32_t getNumPoints();
  inline void setNumPoints( ::int32_t value);

  inline bool hasFilename();
  inline  ::capnp::Text::Builder getFilename();
  inline void setFilename( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFilename(unsigned int size);
  inline void adoptFilename(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFilename();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MetaDataEntry::Pipeline {
public:
  typedef MetaDataEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MetaData::Reader {
public:
  typedef MetaData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasBox() const;
  inline  ::vmtsmap::BoxType::Reader getBox() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MetaData::Builder {
public:
  typedef MetaData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBox();
  inline  ::vmtsmap::BoxType::Builder getBox();
  inline void setBox( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBox();
  inline void adoptBox(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBox();

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::MetaDataEntry>::Reader value);
  inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::MetaDataEntry>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MetaDataEntry>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MetaData::Pipeline {
public:
  typedef MetaData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class MapStruct::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef MapStruct Calls;
  typedef MapStruct Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::vmtsmap::MapStruct::InsertToMapParams,  ::vmtsmap::MapStruct::InsertToMapResults> insertToMapRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::GetPointsParams,  ::vmtsmap::MapStruct::GetPointsResults> getPointsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::InsertPointsInPolygonParams,  ::vmtsmap::MapStruct::InsertPointsInPolygonResults> insertPointsInPolygonRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::AnalyzeParams,  ::vmtsmap::MapStruct::AnalyzeResults> analyzeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ReportParams,  ::vmtsmap::MapStruct::ReportResults> reportRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ReportDoneParams,  ::vmtsmap::MapStruct::ReportDoneResults> reportDoneRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::QueryPolygonParams,  ::vmtsmap::MapStruct::QueryPolygonResults> queryPolygonRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::MissingNeiboursParams,  ::vmtsmap::MapStruct::MissingNeiboursResults> missingNeiboursRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::FindMissingNeighboursParams,  ::vmtsmap::MapStruct::FindMissingNeighboursResults> findMissingNeighboursRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::FindSwappedFeedersParams,  ::vmtsmap::MapStruct::FindSwappedFeedersResults> findSwappedFeedersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::NotifyParams,  ::vmtsmap::MapStruct::NotifyResults> notifyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::CacheMapParams,  ::vmtsmap::MapStruct::CacheMapResults> cacheMapRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::GetPoints2Params,  ::vmtsmap::MapStruct::GetPoints2Results> getPoints2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::QueryPolygon2Params,  ::vmtsmap::MapStruct::QueryPolygon2Results> queryPolygon2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::GetClusteredPointsParams,  ::vmtsmap::MapStruct::GetClusteredPointsResults> getClusteredPointsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::Analyze2Params,  ::vmtsmap::MapStruct::Analyze2Results> analyze2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::Report2Params,  ::vmtsmap::MapStruct::Report2Results> report2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::Notify2Params,  ::vmtsmap::MapStruct::Notify2Results> notify2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::CacheMap2Params,  ::vmtsmap::MapStruct::CacheMap2Results> cacheMap2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ReportPolyParams,  ::vmtsmap::MapStruct::ReportPolyResults> reportPolyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ReportPoly2Params,  ::vmtsmap::MapStruct::ReportPoly2Results> reportPoly2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::FindMissingNeighbours2Params,  ::vmtsmap::MapStruct::FindMissingNeighbours2Results> findMissingNeighbours2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::FindSwappedFeeders2Params,  ::vmtsmap::MapStruct::FindSwappedFeeders2Results> findSwappedFeeders2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::RemoveFromCache2Params,  ::vmtsmap::MapStruct::RemoveFromCache2Results> removeFromCache2Request(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ReloadCellsParams,  ::vmtsmap::MapStruct::ReloadCellsResults> reloadCellsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::QueryCellsParams,  ::vmtsmap::MapStruct::QueryCellsResults> queryCellsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::InsertSignalParams,  ::vmtsmap::MapStruct::InsertSignalResults> insertSignalRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::RemoveSignalParams,  ::vmtsmap::MapStruct::RemoveSignalResults> removeSignalRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::OnCellChangeParams,  ::vmtsmap::MapStruct::OnCellChangeResults> onCellChangeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::UpdateCellParams,  ::vmtsmap::MapStruct::UpdateCellResults> updateCellRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::FinishUpdateCellParams,  ::vmtsmap::MapStruct::FinishUpdateCellResults> finishUpdateCellRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::PingRPCParams,  ::vmtsmap::MapStruct::PingRPCResults> pingRPCRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ToCSVParams,  ::vmtsmap::MapStruct::ToCSVResults> toCSVRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::ExportCellCSVParams,  ::vmtsmap::MapStruct::ExportCellCSVResults> exportCellCSVRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::GenerateParams,  ::vmtsmap::MapStruct::GenerateResults> generateRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::vmtsmap::MapStruct::GetBoxParams,  ::vmtsmap::MapStruct::GetBoxResults> getBoxRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class MapStruct::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef MapStruct Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::vmtsmap::MapStruct::InsertToMapParams InsertToMapParams;
  typedef  ::vmtsmap::MapStruct::InsertToMapResults InsertToMapResults;
  typedef ::capnp::CallContext<InsertToMapParams, InsertToMapResults> InsertToMapContext;
  virtual ::kj::Promise<void> insertToMap(InsertToMapContext context);
  typedef  ::vmtsmap::MapStruct::GetPointsParams GetPointsParams;
  typedef  ::vmtsmap::MapStruct::GetPointsResults GetPointsResults;
  typedef ::capnp::CallContext<GetPointsParams, GetPointsResults> GetPointsContext;
  virtual ::kj::Promise<void> getPoints(GetPointsContext context);
  typedef  ::vmtsmap::MapStruct::InsertPointsInPolygonParams InsertPointsInPolygonParams;
  typedef  ::vmtsmap::MapStruct::InsertPointsInPolygonResults InsertPointsInPolygonResults;
  typedef ::capnp::CallContext<InsertPointsInPolygonParams, InsertPointsInPolygonResults> InsertPointsInPolygonContext;
  virtual ::kj::Promise<void> insertPointsInPolygon(InsertPointsInPolygonContext context);
  typedef  ::vmtsmap::MapStruct::AnalyzeParams AnalyzeParams;
  typedef  ::vmtsmap::MapStruct::AnalyzeResults AnalyzeResults;
  typedef ::capnp::CallContext<AnalyzeParams, AnalyzeResults> AnalyzeContext;
  virtual ::kj::Promise<void> analyze(AnalyzeContext context);
  typedef  ::vmtsmap::MapStruct::ReportParams ReportParams;
  typedef  ::vmtsmap::MapStruct::ReportResults ReportResults;
  typedef ::capnp::CallContext<ReportParams, ReportResults> ReportContext;
  virtual ::kj::Promise<void> report(ReportContext context);
  typedef  ::vmtsmap::MapStruct::ReportDoneParams ReportDoneParams;
  typedef  ::vmtsmap::MapStruct::ReportDoneResults ReportDoneResults;
  typedef ::capnp::CallContext<ReportDoneParams, ReportDoneResults> ReportDoneContext;
  virtual ::kj::Promise<void> reportDone(ReportDoneContext context);
  typedef  ::vmtsmap::MapStruct::QueryPolygonParams QueryPolygonParams;
  typedef  ::vmtsmap::MapStruct::QueryPolygonResults QueryPolygonResults;
  typedef ::capnp::CallContext<QueryPolygonParams, QueryPolygonResults> QueryPolygonContext;
  virtual ::kj::Promise<void> queryPolygon(QueryPolygonContext context);
  typedef  ::vmtsmap::MapStruct::MissingNeiboursParams MissingNeiboursParams;
  typedef  ::vmtsmap::MapStruct::MissingNeiboursResults MissingNeiboursResults;
  typedef ::capnp::CallContext<MissingNeiboursParams, MissingNeiboursResults> MissingNeiboursContext;
  virtual ::kj::Promise<void> missingNeibours(MissingNeiboursContext context);
  typedef  ::vmtsmap::MapStruct::FindMissingNeighboursParams FindMissingNeighboursParams;
  typedef  ::vmtsmap::MapStruct::FindMissingNeighboursResults FindMissingNeighboursResults;
  typedef ::capnp::CallContext<FindMissingNeighboursParams, FindMissingNeighboursResults> FindMissingNeighboursContext;
  virtual ::kj::Promise<void> findMissingNeighbours(FindMissingNeighboursContext context);
  typedef  ::vmtsmap::MapStruct::FindSwappedFeedersParams FindSwappedFeedersParams;
  typedef  ::vmtsmap::MapStruct::FindSwappedFeedersResults FindSwappedFeedersResults;
  typedef ::capnp::CallContext<FindSwappedFeedersParams, FindSwappedFeedersResults> FindSwappedFeedersContext;
  virtual ::kj::Promise<void> findSwappedFeeders(FindSwappedFeedersContext context);
  typedef  ::vmtsmap::MapStruct::NotifyParams NotifyParams;
  typedef  ::vmtsmap::MapStruct::NotifyResults NotifyResults;
  typedef ::capnp::CallContext<NotifyParams, NotifyResults> NotifyContext;
  virtual ::kj::Promise<void> notify(NotifyContext context);
  typedef  ::vmtsmap::MapStruct::CacheMapParams CacheMapParams;
  typedef  ::vmtsmap::MapStruct::CacheMapResults CacheMapResults;
  typedef ::capnp::CallContext<CacheMapParams, CacheMapResults> CacheMapContext;
  virtual ::kj::Promise<void> cacheMap(CacheMapContext context);
  typedef  ::vmtsmap::MapStruct::GetPoints2Params GetPoints2Params;
  typedef  ::vmtsmap::MapStruct::GetPoints2Results GetPoints2Results;
  typedef ::capnp::CallContext<GetPoints2Params, GetPoints2Results> GetPoints2Context;
  virtual ::kj::Promise<void> getPoints2(GetPoints2Context context);
  typedef  ::vmtsmap::MapStruct::QueryPolygon2Params QueryPolygon2Params;
  typedef  ::vmtsmap::MapStruct::QueryPolygon2Results QueryPolygon2Results;
  typedef ::capnp::CallContext<QueryPolygon2Params, QueryPolygon2Results> QueryPolygon2Context;
  virtual ::kj::Promise<void> queryPolygon2(QueryPolygon2Context context);
  typedef  ::vmtsmap::MapStruct::GetClusteredPointsParams GetClusteredPointsParams;
  typedef  ::vmtsmap::MapStruct::GetClusteredPointsResults GetClusteredPointsResults;
  typedef ::capnp::CallContext<GetClusteredPointsParams, GetClusteredPointsResults> GetClusteredPointsContext;
  virtual ::kj::Promise<void> getClusteredPoints(GetClusteredPointsContext context);
  typedef  ::vmtsmap::MapStruct::Analyze2Params Analyze2Params;
  typedef  ::vmtsmap::MapStruct::Analyze2Results Analyze2Results;
  typedef ::capnp::CallContext<Analyze2Params, Analyze2Results> Analyze2Context;
  virtual ::kj::Promise<void> analyze2(Analyze2Context context);
  typedef  ::vmtsmap::MapStruct::Report2Params Report2Params;
  typedef  ::vmtsmap::MapStruct::Report2Results Report2Results;
  typedef ::capnp::CallContext<Report2Params, Report2Results> Report2Context;
  virtual ::kj::Promise<void> report2(Report2Context context);
  typedef  ::vmtsmap::MapStruct::Notify2Params Notify2Params;
  typedef  ::vmtsmap::MapStruct::Notify2Results Notify2Results;
  typedef ::capnp::CallContext<Notify2Params, Notify2Results> Notify2Context;
  virtual ::kj::Promise<void> notify2(Notify2Context context);
  typedef  ::vmtsmap::MapStruct::CacheMap2Params CacheMap2Params;
  typedef  ::vmtsmap::MapStruct::CacheMap2Results CacheMap2Results;
  typedef ::capnp::CallContext<CacheMap2Params, CacheMap2Results> CacheMap2Context;
  virtual ::kj::Promise<void> cacheMap2(CacheMap2Context context);
  typedef  ::vmtsmap::MapStruct::ReportPolyParams ReportPolyParams;
  typedef  ::vmtsmap::MapStruct::ReportPolyResults ReportPolyResults;
  typedef ::capnp::CallContext<ReportPolyParams, ReportPolyResults> ReportPolyContext;
  virtual ::kj::Promise<void> reportPoly(ReportPolyContext context);
  typedef  ::vmtsmap::MapStruct::ReportPoly2Params ReportPoly2Params;
  typedef  ::vmtsmap::MapStruct::ReportPoly2Results ReportPoly2Results;
  typedef ::capnp::CallContext<ReportPoly2Params, ReportPoly2Results> ReportPoly2Context;
  virtual ::kj::Promise<void> reportPoly2(ReportPoly2Context context);
  typedef  ::vmtsmap::MapStruct::FindMissingNeighbours2Params FindMissingNeighbours2Params;
  typedef  ::vmtsmap::MapStruct::FindMissingNeighbours2Results FindMissingNeighbours2Results;
  typedef ::capnp::CallContext<FindMissingNeighbours2Params, FindMissingNeighbours2Results> FindMissingNeighbours2Context;
  virtual ::kj::Promise<void> findMissingNeighbours2(FindMissingNeighbours2Context context);
  typedef  ::vmtsmap::MapStruct::FindSwappedFeeders2Params FindSwappedFeeders2Params;
  typedef  ::vmtsmap::MapStruct::FindSwappedFeeders2Results FindSwappedFeeders2Results;
  typedef ::capnp::CallContext<FindSwappedFeeders2Params, FindSwappedFeeders2Results> FindSwappedFeeders2Context;
  virtual ::kj::Promise<void> findSwappedFeeders2(FindSwappedFeeders2Context context);
  typedef  ::vmtsmap::MapStruct::RemoveFromCache2Params RemoveFromCache2Params;
  typedef  ::vmtsmap::MapStruct::RemoveFromCache2Results RemoveFromCache2Results;
  typedef ::capnp::CallContext<RemoveFromCache2Params, RemoveFromCache2Results> RemoveFromCache2Context;
  virtual ::kj::Promise<void> removeFromCache2(RemoveFromCache2Context context);
  typedef  ::vmtsmap::MapStruct::ReloadCellsParams ReloadCellsParams;
  typedef  ::vmtsmap::MapStruct::ReloadCellsResults ReloadCellsResults;
  typedef ::capnp::CallContext<ReloadCellsParams, ReloadCellsResults> ReloadCellsContext;
  virtual ::kj::Promise<void> reloadCells(ReloadCellsContext context);
  typedef  ::vmtsmap::MapStruct::QueryCellsParams QueryCellsParams;
  typedef  ::vmtsmap::MapStruct::QueryCellsResults QueryCellsResults;
  typedef ::capnp::CallContext<QueryCellsParams, QueryCellsResults> QueryCellsContext;
  virtual ::kj::Promise<void> queryCells(QueryCellsContext context);
  typedef  ::vmtsmap::MapStruct::InsertSignalParams InsertSignalParams;
  typedef  ::vmtsmap::MapStruct::InsertSignalResults InsertSignalResults;
  typedef ::capnp::CallContext<InsertSignalParams, InsertSignalResults> InsertSignalContext;
  virtual ::kj::Promise<void> insertSignal(InsertSignalContext context);
  typedef  ::vmtsmap::MapStruct::RemoveSignalParams RemoveSignalParams;
  typedef  ::vmtsmap::MapStruct::RemoveSignalResults RemoveSignalResults;
  typedef ::capnp::CallContext<RemoveSignalParams, RemoveSignalResults> RemoveSignalContext;
  virtual ::kj::Promise<void> removeSignal(RemoveSignalContext context);
  typedef  ::vmtsmap::MapStruct::OnCellChangeParams OnCellChangeParams;
  typedef  ::vmtsmap::MapStruct::OnCellChangeResults OnCellChangeResults;
  typedef ::capnp::CallContext<OnCellChangeParams, OnCellChangeResults> OnCellChangeContext;
  virtual ::kj::Promise<void> onCellChange(OnCellChangeContext context);
  typedef  ::vmtsmap::MapStruct::UpdateCellParams UpdateCellParams;
  typedef  ::vmtsmap::MapStruct::UpdateCellResults UpdateCellResults;
  typedef ::capnp::CallContext<UpdateCellParams, UpdateCellResults> UpdateCellContext;
  virtual ::kj::Promise<void> updateCell(UpdateCellContext context);
  typedef  ::vmtsmap::MapStruct::FinishUpdateCellParams FinishUpdateCellParams;
  typedef  ::vmtsmap::MapStruct::FinishUpdateCellResults FinishUpdateCellResults;
  typedef ::capnp::CallContext<FinishUpdateCellParams, FinishUpdateCellResults> FinishUpdateCellContext;
  virtual ::kj::Promise<void> finishUpdateCell(FinishUpdateCellContext context);
  typedef  ::vmtsmap::MapStruct::PingRPCParams PingRPCParams;
  typedef  ::vmtsmap::MapStruct::PingRPCResults PingRPCResults;
  typedef ::capnp::CallContext<PingRPCParams, PingRPCResults> PingRPCContext;
  virtual ::kj::Promise<void> pingRPC(PingRPCContext context);
  typedef  ::vmtsmap::MapStruct::ToCSVParams ToCSVParams;
  typedef  ::vmtsmap::MapStruct::ToCSVResults ToCSVResults;
  typedef ::capnp::CallContext<ToCSVParams, ToCSVResults> ToCSVContext;
  virtual ::kj::Promise<void> toCSV(ToCSVContext context);
  typedef  ::vmtsmap::MapStruct::ExportCellCSVParams ExportCellCSVParams;
  typedef  ::vmtsmap::MapStruct::ExportCellCSVResults ExportCellCSVResults;
  typedef ::capnp::CallContext<ExportCellCSVParams, ExportCellCSVResults> ExportCellCSVContext;
  virtual ::kj::Promise<void> exportCellCSV(ExportCellCSVContext context);
  typedef  ::vmtsmap::MapStruct::GenerateParams GenerateParams;
  typedef  ::vmtsmap::MapStruct::GenerateResults GenerateResults;
  typedef ::capnp::CallContext<GenerateParams, GenerateResults> GenerateContext;
  virtual ::kj::Promise<void> generate(GenerateContext context);
  typedef  ::vmtsmap::MapStruct::GetBoxParams GetBoxParams;
  typedef  ::vmtsmap::MapStruct::GetBoxResults GetBoxResults;
  typedef ::capnp::CallContext<GetBoxParams, GetBoxResults> GetBoxContext;
  virtual ::kj::Promise<void> getBox(GetBoxContext context);

  inline  ::vmtsmap::MapStruct::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::vmtsmap::MapStruct>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class MapStruct::InsertToMapParams::Reader {
public:
  typedef InsertToMapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasRect() const;
  inline  ::vmtsmap::Rect::Reader getRect() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertToMapParams::Builder {
public:
  typedef InsertToMapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasRect();
  inline  ::vmtsmap::Rect::Builder getRect();
  inline void setRect( ::vmtsmap::Rect::Reader value);
  inline  ::vmtsmap::Rect::Builder initRect();
  inline void adoptRect(::capnp::Orphan< ::vmtsmap::Rect>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Rect> disownRect();

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertToMapParams::Pipeline {
public:
  typedef InsertToMapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::Rect::Pipeline getRect();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::InsertToMapResults::Reader {
public:
  typedef InsertToMapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertToMapResults::Builder {
public:
  typedef InsertToMapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertToMapResults::Pipeline {
public:
  typedef InsertToMapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetPointsParams::Reader {
public:
  typedef GetPointsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasRect() const;
  inline  ::vmtsmap::Rect::Reader getRect() const;

  inline bool hasExtra() const;
  inline  ::vmtsmap::ClusterParam::Reader getExtra() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetPointsParams::Builder {
public:
  typedef GetPointsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasRect();
  inline  ::vmtsmap::Rect::Builder getRect();
  inline void setRect( ::vmtsmap::Rect::Reader value);
  inline  ::vmtsmap::Rect::Builder initRect();
  inline void adoptRect(::capnp::Orphan< ::vmtsmap::Rect>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Rect> disownRect();

  inline bool hasExtra();
  inline  ::vmtsmap::ClusterParam::Builder getExtra();
  inline void setExtra( ::vmtsmap::ClusterParam::Reader value);
  inline  ::vmtsmap::ClusterParam::Builder initExtra();
  inline void adoptExtra(::capnp::Orphan< ::vmtsmap::ClusterParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ClusterParam> disownExtra();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetPointsParams::Pipeline {
public:
  typedef GetPointsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::Rect::Pipeline getRect();
  inline  ::vmtsmap::ClusterParam::Pipeline getExtra();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetPointsResults::Reader {
public:
  typedef GetPointsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::Results::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetPointsResults::Builder {
public:
  typedef GetPointsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::Results::Builder getResult();
  inline void setResult( ::vmtsmap::Results::Reader value);
  inline  ::vmtsmap::Results::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::Results>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Results> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetPointsResults::Pipeline {
public:
  typedef GetPointsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Results::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::InsertPointsInPolygonParams::Reader {
public:
  typedef InsertPointsInPolygonParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasPolygons() const;
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader getPolygons() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getData() const;

  inline bool getStrictWithin() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertPointsInPolygonParams::Builder {
public:
  typedef InsertPointsInPolygonParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasPolygons();
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder getPolygons();
  inline void setPolygons( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value);
  inline void setPolygons(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder initPolygons(unsigned int size);
  inline void adoptPolygons(::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> disownPolygons();

  inline bool hasData();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getData();
  inline void setData( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownData();

  inline bool getStrictWithin();
  inline void setStrictWithin(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertPointsInPolygonParams::Pipeline {
public:
  typedef InsertPointsInPolygonParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::InsertPointsInPolygonResults::Reader {
public:
  typedef InsertPointsInPolygonResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertPointsInPolygonResults::Builder {
public:
  typedef InsertPointsInPolygonResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getResult();
  inline void setResult( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertPointsInPolygonResults::Pipeline {
public:
  typedef InsertPointsInPolygonResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::AnalyzeParams::Reader {
public:
  typedef AnalyzeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasRect() const;
  inline  ::vmtsmap::Rect::Reader getRect() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::AnalyzeParams::Builder {
public:
  typedef AnalyzeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasRect();
  inline  ::vmtsmap::Rect::Builder getRect();
  inline void setRect( ::vmtsmap::Rect::Reader value);
  inline  ::vmtsmap::Rect::Builder initRect();
  inline void adoptRect(::capnp::Orphan< ::vmtsmap::Rect>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Rect> disownRect();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::AnalyzeParams::Pipeline {
public:
  typedef AnalyzeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::Rect::Pipeline getRect();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::AnalyzeResults::Reader {
public:
  typedef AnalyzeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::ResultType>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::AnalyzeResults::Builder {
public:
  typedef AnalyzeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::ResultType>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::ResultType>::Reader value);
  inline  ::capnp::List< ::vmtsmap::ResultType>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::AnalyzeResults::Pipeline {
public:
  typedef AnalyzeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportParams::Reader {
public:
  typedef ReportParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportParams::Builder {
public:
  typedef ReportParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportParams::Pipeline {
public:
  typedef ReportParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportResults::Reader {
public:
  typedef ReportResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::OverlapFinalReport::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportResults::Builder {
public:
  typedef ReportResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::OverlapFinalReport::Builder getResult();
  inline void setResult( ::vmtsmap::OverlapFinalReport::Reader value);
  inline  ::vmtsmap::OverlapFinalReport::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value);
  inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportResults::Pipeline {
public:
  typedef ReportResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::OverlapFinalReport::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportDoneParams::Reader {
public:
  typedef ReportDoneParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportDoneParams::Builder {
public:
  typedef ReportDoneParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportDoneParams::Pipeline {
public:
  typedef ReportDoneParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportDoneResults::Reader {
public:
  typedef ReportDoneResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportDoneResults::Builder {
public:
  typedef ReportDoneResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportDoneResults::Pipeline {
public:
  typedef ReportDoneResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryPolygonParams::Reader {
public:
  typedef QueryPolygonParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasPoly() const;
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader getPoly() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryPolygonParams::Builder {
public:
  typedef QueryPolygonParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasPoly();
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder getPoly();
  inline void setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder initPoly(unsigned int size);
  inline void adoptPoly(::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> disownPoly();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryPolygonParams::Pipeline {
public:
  typedef QueryPolygonParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryPolygonResults::Reader {
public:
  typedef QueryPolygonResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryPolygonResults::Builder {
public:
  typedef QueryPolygonResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryPolygonResults::Pipeline {
public:
  typedef QueryPolygonResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::MissingNeiboursParams::Reader {
public:
  typedef MissingNeiboursParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasRect() const;
  inline  ::vmtsmap::Rect::Reader getRect() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

  inline bool hasParam() const;
  inline  ::vmtsmap::MissingNeighbourParam::Reader getParam() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::MissingNeiboursParams::Builder {
public:
  typedef MissingNeiboursParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasRect();
  inline  ::vmtsmap::Rect::Builder getRect();
  inline void setRect( ::vmtsmap::Rect::Reader value);
  inline  ::vmtsmap::Rect::Builder initRect();
  inline void adoptRect(::capnp::Orphan< ::vmtsmap::Rect>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Rect> disownRect();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

  inline bool hasParam();
  inline  ::vmtsmap::MissingNeighbourParam::Builder getParam();
  inline void setParam( ::vmtsmap::MissingNeighbourParam::Reader value);
  inline  ::vmtsmap::MissingNeighbourParam::Builder initParam();
  inline void adoptParam(::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> disownParam();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::MissingNeiboursParams::Pipeline {
public:
  typedef MissingNeiboursParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::Rect::Pipeline getRect();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
  inline  ::vmtsmap::MissingNeighbourParam::Pipeline getParam();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::MissingNeiboursResults::Reader {
public:
  typedef MissingNeiboursResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::MissingNeiboursResults::Builder {
public:
  typedef MissingNeiboursResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value);
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::MissingNeiboursResults::Pipeline {
public:
  typedef MissingNeiboursResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindMissingNeighboursParams::Reader {
public:
  typedef FindMissingNeighboursParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

  inline bool hasParam() const;
  inline  ::vmtsmap::MissingNeighbourParam::Reader getParam() const;

  inline bool hasArea() const;
  inline  ::vmtsmap::ResultType::Reader getArea() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindMissingNeighboursParams::Builder {
public:
  typedef FindMissingNeighboursParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

  inline bool hasParam();
  inline  ::vmtsmap::MissingNeighbourParam::Builder getParam();
  inline void setParam( ::vmtsmap::MissingNeighbourParam::Reader value);
  inline  ::vmtsmap::MissingNeighbourParam::Builder initParam();
  inline void adoptParam(::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> disownParam();

  inline bool hasArea();
  inline  ::vmtsmap::ResultType::Builder getArea();
  inline void setArea( ::vmtsmap::ResultType::Reader value);
  inline  ::vmtsmap::ResultType::Builder initArea();
  inline void adoptArea(::capnp::Orphan< ::vmtsmap::ResultType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ResultType> disownArea();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindMissingNeighboursParams::Pipeline {
public:
  typedef FindMissingNeighboursParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
  inline  ::vmtsmap::MissingNeighbourParam::Pipeline getParam();
  inline  ::vmtsmap::ResultType::Pipeline getArea();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindMissingNeighboursResults::Reader {
public:
  typedef FindMissingNeighboursResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindMissingNeighboursResults::Builder {
public:
  typedef FindMissingNeighboursResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value);
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindMissingNeighboursResults::Pipeline {
public:
  typedef FindMissingNeighboursResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindSwappedFeedersParams::Reader {
public:
  typedef FindSwappedFeedersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

  inline bool hasParam() const;
  inline  ::vmtsmap::FeederParams::Reader getParam() const;

  inline bool hasArea() const;
  inline  ::vmtsmap::ResultType::Reader getArea() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindSwappedFeedersParams::Builder {
public:
  typedef FindSwappedFeedersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

  inline bool hasParam();
  inline  ::vmtsmap::FeederParams::Builder getParam();
  inline void setParam( ::vmtsmap::FeederParams::Reader value);
  inline  ::vmtsmap::FeederParams::Builder initParam();
  inline void adoptParam(::capnp::Orphan< ::vmtsmap::FeederParams>&& value);
  inline ::capnp::Orphan< ::vmtsmap::FeederParams> disownParam();

  inline bool hasArea();
  inline  ::vmtsmap::ResultType::Builder getArea();
  inline void setArea( ::vmtsmap::ResultType::Reader value);
  inline  ::vmtsmap::ResultType::Builder initArea();
  inline void adoptArea(::capnp::Orphan< ::vmtsmap::ResultType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ResultType> disownArea();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindSwappedFeedersParams::Pipeline {
public:
  typedef FindSwappedFeedersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
  inline  ::vmtsmap::FeederParams::Pipeline getParam();
  inline  ::vmtsmap::ResultType::Pipeline getArea();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindSwappedFeedersResults::Reader {
public:
  typedef FindSwappedFeedersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindSwappedFeedersResults::Builder {
public:
  typedef FindSwappedFeedersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::CellInfo>::Reader value);
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindSwappedFeedersResults::Pipeline {
public:
  typedef FindSwappedFeedersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::NotifyParams::Reader {
public:
  typedef NotifyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::NotifyParams::Builder {
public:
  typedef NotifyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::NotifyParams::Pipeline {
public:
  typedef NotifyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::NotifyResults::Reader {
public:
  typedef NotifyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Text::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::NotifyResults::Builder {
public:
  typedef NotifyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Text::Builder getResult();
  inline void setResult( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::NotifyResults::Pipeline {
public:
  typedef NotifyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::CacheMapParams::Reader {
public:
  typedef CacheMapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::CacheMapParams::Builder {
public:
  typedef CacheMapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::CacheMapParams::Pipeline {
public:
  typedef CacheMapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::CacheMapResults::Reader {
public:
  typedef CacheMapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::CacheMapResults::Builder {
public:
  typedef CacheMapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::CacheMapResults::Pipeline {
public:
  typedef CacheMapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetPoints2Params::Reader {
public:
  typedef GetPoints2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasRect() const;
  inline  ::vmtsmap::Rect::Reader getRect() const;

  inline bool hasExtra() const;
  inline  ::vmtsmap::ClusterParam::Reader getExtra() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetPoints2Params::Builder {
public:
  typedef GetPoints2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasRect();
  inline  ::vmtsmap::Rect::Builder getRect();
  inline void setRect( ::vmtsmap::Rect::Reader value);
  inline  ::vmtsmap::Rect::Builder initRect();
  inline void adoptRect(::capnp::Orphan< ::vmtsmap::Rect>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Rect> disownRect();

  inline bool hasExtra();
  inline  ::vmtsmap::ClusterParam::Builder getExtra();
  inline void setExtra( ::vmtsmap::ClusterParam::Reader value);
  inline  ::vmtsmap::ClusterParam::Builder initExtra();
  inline void adoptExtra(::capnp::Orphan< ::vmtsmap::ClusterParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ClusterParam> disownExtra();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetPoints2Params::Pipeline {
public:
  typedef GetPoints2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::Rect::Pipeline getRect();
  inline  ::vmtsmap::ClusterParam::Pipeline getExtra();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetPoints2Results::Reader {
public:
  typedef GetPoints2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetPoints2Results::Builder {
public:
  typedef GetPoints2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetPoints2Results::Pipeline {
public:
  typedef GetPoints2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryPolygon2Params::Reader {
public:
  typedef QueryPolygon2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasPoly() const;
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader getPoly() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryPolygon2Params::Builder {
public:
  typedef QueryPolygon2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasPoly();
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder getPoly();
  inline void setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder initPoly(unsigned int size);
  inline void adoptPoly(::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> disownPoly();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryPolygon2Params::Pipeline {
public:
  typedef QueryPolygon2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryPolygon2Results::Reader {
public:
  typedef QueryPolygon2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::Point>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryPolygon2Results::Builder {
public:
  typedef QueryPolygon2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::Point>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::Point>::Reader value);
  inline  ::capnp::List< ::vmtsmap::Point>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryPolygon2Results::Pipeline {
public:
  typedef QueryPolygon2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetClusteredPointsParams::Reader {
public:
  typedef GetClusteredPointsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasBox() const;
  inline  ::vmtsmap::BoxType::Reader getBox() const;

  inline bool hasExtra() const;
  inline  ::vmtsmap::ClusterParam::Reader getExtra() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetClusteredPointsParams::Builder {
public:
  typedef GetClusteredPointsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasBox();
  inline  ::vmtsmap::BoxType::Builder getBox();
  inline void setBox( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBox();
  inline void adoptBox(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBox();

  inline bool hasExtra();
  inline  ::vmtsmap::ClusterParam::Builder getExtra();
  inline void setExtra( ::vmtsmap::ClusterParam::Reader value);
  inline  ::vmtsmap::ClusterParam::Builder initExtra();
  inline void adoptExtra(::capnp::Orphan< ::vmtsmap::ClusterParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ClusterParam> disownExtra();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetClusteredPointsParams::Pipeline {
public:
  typedef GetClusteredPointsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::BoxType::Pipeline getBox();
  inline  ::vmtsmap::ClusterParam::Pipeline getExtra();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetClusteredPointsResults::Reader {
public:
  typedef GetClusteredPointsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::PointDataVector::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetClusteredPointsResults::Builder {
public:
  typedef GetClusteredPointsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::PointDataVector::Builder getResult();
  inline void setResult( ::vmtsmap::PointDataVector::Reader value);
  inline  ::vmtsmap::PointDataVector::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::PointDataVector>&& value);
  inline ::capnp::Orphan< ::vmtsmap::PointDataVector> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetClusteredPointsResults::Pipeline {
public:
  typedef GetClusteredPointsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::PointDataVector::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Analyze2Params::Reader {
public:
  typedef Analyze2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Analyze2Params::Builder {
public:
  typedef Analyze2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Analyze2Params::Pipeline {
public:
  typedef Analyze2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Analyze2Results::Reader {
public:
  typedef Analyze2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::ResultType>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Analyze2Results::Builder {
public:
  typedef Analyze2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::ResultType>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::ResultType>::Reader value);
  inline  ::capnp::List< ::vmtsmap::ResultType>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Analyze2Results::Pipeline {
public:
  typedef Analyze2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Report2Params::Reader {
public:
  typedef Report2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Report2Params::Builder {
public:
  typedef Report2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Report2Params::Pipeline {
public:
  typedef Report2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Report2Results::Reader {
public:
  typedef Report2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::OverlapFinalReport::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Report2Results::Builder {
public:
  typedef Report2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::OverlapFinalReport::Builder getResult();
  inline void setResult( ::vmtsmap::OverlapFinalReport::Reader value);
  inline  ::vmtsmap::OverlapFinalReport::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value);
  inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Report2Results::Pipeline {
public:
  typedef Report2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::OverlapFinalReport::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Notify2Params::Reader {
public:
  typedef Notify2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Notify2Params::Builder {
public:
  typedef Notify2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Notify2Params::Pipeline {
public:
  typedef Notify2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::Notify2Results::Reader {
public:
  typedef Notify2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Text::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::Notify2Results::Builder {
public:
  typedef Notify2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Text::Builder getResult();
  inline void setResult( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::Notify2Results::Pipeline {
public:
  typedef Notify2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::CacheMap2Params::Reader {
public:
  typedef CacheMap2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::CacheMap2Params::Builder {
public:
  typedef CacheMap2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::CacheMap2Params::Pipeline {
public:
  typedef CacheMap2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::CacheMap2Results::Reader {
public:
  typedef CacheMap2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::CacheMap2Results::Builder {
public:
  typedef CacheMap2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::CacheMap2Results::Pipeline {
public:
  typedef CacheMap2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportPolyParams::Reader {
public:
  typedef ReportPolyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasPoly() const;
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader getPoly() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportPolyParams::Builder {
public:
  typedef ReportPolyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasPoly();
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder getPoly();
  inline void setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder initPoly(unsigned int size);
  inline void adoptPoly(::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> disownPoly();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportPolyParams::Pipeline {
public:
  typedef ReportPolyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportPolyResults::Reader {
public:
  typedef ReportPolyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::OverlapFinalReport::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportPolyResults::Builder {
public:
  typedef ReportPolyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::OverlapFinalReport::Builder getResult();
  inline void setResult( ::vmtsmap::OverlapFinalReport::Reader value);
  inline  ::vmtsmap::OverlapFinalReport::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value);
  inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportPolyResults::Pipeline {
public:
  typedef ReportPolyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::OverlapFinalReport::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportPoly2Params::Reader {
public:
  typedef ReportPoly2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasPoly() const;
  inline  ::capnp::List< ::vmtsmap::PointType>::Reader getPoly() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportPoly2Params::Builder {
public:
  typedef ReportPoly2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasPoly();
  inline  ::capnp::List< ::vmtsmap::PointType>::Builder getPoly();
  inline void setPoly( ::capnp::List< ::vmtsmap::PointType>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointType>::Builder initPoly(unsigned int size);
  inline void adoptPoly(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>> disownPoly();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportPoly2Params::Pipeline {
public:
  typedef ReportPoly2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReportPoly2Results::Reader {
public:
  typedef ReportPoly2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::OverlapFinalReport::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReportPoly2Results::Builder {
public:
  typedef ReportPoly2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::OverlapFinalReport::Builder getResult();
  inline void setResult( ::vmtsmap::OverlapFinalReport::Reader value);
  inline  ::vmtsmap::OverlapFinalReport::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value);
  inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReportPoly2Results::Pipeline {
public:
  typedef ReportPoly2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::OverlapFinalReport::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindMissingNeighbours2Params::Reader {
public:
  typedef FindMissingNeighbours2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

  inline bool hasParam() const;
  inline  ::vmtsmap::MissingNeighbourParam::Reader getParam() const;

  inline bool hasArea() const;
  inline  ::vmtsmap::ResultType::Reader getArea() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindMissingNeighbours2Params::Builder {
public:
  typedef FindMissingNeighbours2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

  inline bool hasParam();
  inline  ::vmtsmap::MissingNeighbourParam::Builder getParam();
  inline void setParam( ::vmtsmap::MissingNeighbourParam::Reader value);
  inline  ::vmtsmap::MissingNeighbourParam::Builder initParam();
  inline void adoptParam(::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value);
  inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> disownParam();

  inline bool hasArea();
  inline  ::vmtsmap::ResultType::Builder getArea();
  inline void setArea( ::vmtsmap::ResultType::Reader value);
  inline  ::vmtsmap::ResultType::Builder initArea();
  inline void adoptArea(::capnp::Orphan< ::vmtsmap::ResultType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ResultType> disownArea();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindMissingNeighbours2Params::Pipeline {
public:
  typedef FindMissingNeighbours2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
  inline  ::vmtsmap::MissingNeighbourParam::Pipeline getParam();
  inline  ::vmtsmap::ResultType::Pipeline getArea();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindMissingNeighbours2Results::Reader {
public:
  typedef FindMissingNeighbours2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindMissingNeighbours2Results::Builder {
public:
  typedef FindMissingNeighbours2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value);
  inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindMissingNeighbours2Results::Pipeline {
public:
  typedef FindMissingNeighbours2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindSwappedFeeders2Params::Reader {
public:
  typedef FindSwappedFeeders2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasOptions() const;
  inline  ::vmtsmap::AnalysisOptions::Reader getOptions() const;

  inline bool hasParam() const;
  inline  ::vmtsmap::FeederParams::Reader getParam() const;

  inline bool hasArea() const;
  inline  ::vmtsmap::ResultType::Reader getArea() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindSwappedFeeders2Params::Builder {
public:
  typedef FindSwappedFeeders2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasOptions();
  inline  ::vmtsmap::AnalysisOptions::Builder getOptions();
  inline void setOptions( ::vmtsmap::AnalysisOptions::Reader value);
  inline  ::vmtsmap::AnalysisOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> disownOptions();

  inline bool hasParam();
  inline  ::vmtsmap::FeederParams::Builder getParam();
  inline void setParam( ::vmtsmap::FeederParams::Reader value);
  inline  ::vmtsmap::FeederParams::Builder initParam();
  inline void adoptParam(::capnp::Orphan< ::vmtsmap::FeederParams>&& value);
  inline ::capnp::Orphan< ::vmtsmap::FeederParams> disownParam();

  inline bool hasArea();
  inline  ::vmtsmap::ResultType::Builder getArea();
  inline void setArea( ::vmtsmap::ResultType::Reader value);
  inline  ::vmtsmap::ResultType::Builder initArea();
  inline void adoptArea(::capnp::Orphan< ::vmtsmap::ResultType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::ResultType> disownArea();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindSwappedFeeders2Params::Pipeline {
public:
  typedef FindSwappedFeeders2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::AnalysisOptions::Pipeline getOptions();
  inline  ::vmtsmap::FeederParams::Pipeline getParam();
  inline  ::vmtsmap::ResultType::Pipeline getArea();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FindSwappedFeeders2Results::Reader {
public:
  typedef FindSwappedFeeders2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FindSwappedFeeders2Results::Builder {
public:
  typedef FindSwappedFeeders2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::CellInfo>::Reader value);
  inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FindSwappedFeeders2Results::Pipeline {
public:
  typedef FindSwappedFeeders2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::RemoveFromCache2Params::Reader {
public:
  typedef RemoveFromCache2Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::RemoveFromCache2Params::Builder {
public:
  typedef RemoveFromCache2Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::RemoveFromCache2Params::Pipeline {
public:
  typedef RemoveFromCache2Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::RemoveFromCache2Results::Reader {
public:
  typedef RemoveFromCache2Results Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::RemoveFromCache2Results::Builder {
public:
  typedef RemoveFromCache2Results Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::RemoveFromCache2Results::Pipeline {
public:
  typedef RemoveFromCache2Results Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReloadCellsParams::Reader {
public:
  typedef ReloadCellsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReloadCellsParams::Builder {
public:
  typedef ReloadCellsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReloadCellsParams::Pipeline {
public:
  typedef ReloadCellsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ReloadCellsResults::Reader {
public:
  typedef ReloadCellsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ReloadCellsResults::Builder {
public:
  typedef ReloadCellsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ReloadCellsResults::Pipeline {
public:
  typedef ReloadCellsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryCellsParams::Reader {
public:
  typedef QueryCellsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasBox() const;
  inline  ::vmtsmap::BoxType::Reader getBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryCellsParams::Builder {
public:
  typedef QueryCellsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBox();
  inline  ::vmtsmap::BoxType::Builder getBox();
  inline void setBox( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBox();
  inline void adoptBox(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryCellsParams::Pipeline {
public:
  typedef QueryCellsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::QueryCellsResults::Reader {
public:
  typedef QueryCellsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::QueryCellsResults::Builder {
public:
  typedef QueryCellsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::CellDataInfo>::Reader value);
  inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataInfo>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::QueryCellsResults::Pipeline {
public:
  typedef QueryCellsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::InsertSignalParams::Reader {
public:
  typedef InsertSignalParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMsg() const;
  inline  ::vmtsmap::AddSignalMsg2::Reader getMsg() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertSignalParams::Builder {
public:
  typedef InsertSignalParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMsg();
  inline  ::vmtsmap::AddSignalMsg2::Builder getMsg();
  inline void setMsg( ::vmtsmap::AddSignalMsg2::Reader value);
  inline  ::vmtsmap::AddSignalMsg2::Builder initMsg();
  inline void adoptMsg(::capnp::Orphan< ::vmtsmap::AddSignalMsg2>&& value);
  inline ::capnp::Orphan< ::vmtsmap::AddSignalMsg2> disownMsg();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertSignalParams::Pipeline {
public:
  typedef InsertSignalParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::AddSignalMsg2::Pipeline getMsg();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::InsertSignalResults::Reader {
public:
  typedef InsertSignalResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::InsertSignalResults::Builder {
public:
  typedef InsertSignalResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::InsertSignalResults::Pipeline {
public:
  typedef InsertSignalResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::RemoveSignalParams::Reader {
public:
  typedef RemoveSignalParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasMsg() const;
  inline  ::vmtsmap::DeleteSignalMsg2::Reader getMsg() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::RemoveSignalParams::Builder {
public:
  typedef RemoveSignalParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasMsg();
  inline  ::vmtsmap::DeleteSignalMsg2::Builder getMsg();
  inline void setMsg( ::vmtsmap::DeleteSignalMsg2::Reader value);
  inline  ::vmtsmap::DeleteSignalMsg2::Builder initMsg();
  inline void adoptMsg(::capnp::Orphan< ::vmtsmap::DeleteSignalMsg2>&& value);
  inline ::capnp::Orphan< ::vmtsmap::DeleteSignalMsg2> disownMsg();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::RemoveSignalParams::Pipeline {
public:
  typedef RemoveSignalParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
  inline  ::vmtsmap::DeleteSignalMsg2::Pipeline getMsg();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::RemoveSignalResults::Reader {
public:
  typedef RemoveSignalResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::RemoveSignalResults::Builder {
public:
  typedef RemoveSignalResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::RemoveSignalResults::Pipeline {
public:
  typedef RemoveSignalResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::OnCellChangeParams::Reader {
public:
  typedef OnCellChangeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasInsertIds() const;
  inline  ::capnp::List< ::int32_t>::Reader getInsertIds() const;

  inline bool hasUpdateIds() const;
  inline  ::capnp::List< ::int32_t>::Reader getUpdateIds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::OnCellChangeParams::Builder {
public:
  typedef OnCellChangeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInsertIds();
  inline  ::capnp::List< ::int32_t>::Builder getInsertIds();
  inline void setInsertIds( ::capnp::List< ::int32_t>::Reader value);
  inline void setInsertIds(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initInsertIds(unsigned int size);
  inline void adoptInsertIds(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownInsertIds();

  inline bool hasUpdateIds();
  inline  ::capnp::List< ::int32_t>::Builder getUpdateIds();
  inline void setUpdateIds( ::capnp::List< ::int32_t>::Reader value);
  inline void setUpdateIds(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initUpdateIds(unsigned int size);
  inline void adoptUpdateIds(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownUpdateIds();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::OnCellChangeParams::Pipeline {
public:
  typedef OnCellChangeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::OnCellChangeResults::Reader {
public:
  typedef OnCellChangeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::OnCellChangeResults::Builder {
public:
  typedef OnCellChangeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::OnCellChangeResults::Pipeline {
public:
  typedef OnCellChangeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::UpdateCellParams::Reader {
public:
  typedef UpdateCellParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasInserted() const;
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Reader getInserted() const;

  inline bool hasUpdated() const;
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Reader getUpdated() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::UpdateCellParams::Builder {
public:
  typedef UpdateCellParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInserted();
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder getInserted();
  inline void setInserted( ::capnp::List< ::vmtsmap::CellDataExt>::Reader value);
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder initInserted(unsigned int size);
  inline void adoptInserted(::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>> disownInserted();

  inline bool hasUpdated();
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder getUpdated();
  inline void setUpdated( ::capnp::List< ::vmtsmap::CellDataExt>::Reader value);
  inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder initUpdated(unsigned int size);
  inline void adoptUpdated(::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>> disownUpdated();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::UpdateCellParams::Pipeline {
public:
  typedef UpdateCellParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::UpdateCellResults::Reader {
public:
  typedef UpdateCellResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::UpdateCellResults::Builder {
public:
  typedef UpdateCellResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::UpdateCellResults::Pipeline {
public:
  typedef UpdateCellResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FinishUpdateCellParams::Reader {
public:
  typedef FinishUpdateCellParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FinishUpdateCellParams::Builder {
public:
  typedef FinishUpdateCellParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FinishUpdateCellParams::Pipeline {
public:
  typedef FinishUpdateCellParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::FinishUpdateCellResults::Reader {
public:
  typedef FinishUpdateCellResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::FinishUpdateCellResults::Builder {
public:
  typedef FinishUpdateCellResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::FinishUpdateCellResults::Pipeline {
public:
  typedef FinishUpdateCellResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::PingRPCParams::Reader {
public:
  typedef PingRPCParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::PingRPCParams::Builder {
public:
  typedef PingRPCParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::PingRPCParams::Pipeline {
public:
  typedef PingRPCParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::PingRPCResults::Reader {
public:
  typedef PingRPCResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::PingRPCResults::Builder {
public:
  typedef PingRPCResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::PingRPCResults::Pipeline {
public:
  typedef PingRPCResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ToCSVParams::Reader {
public:
  typedef ToCSVParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasFilename() const;
  inline  ::capnp::Text::Reader getFilename() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ToCSVParams::Builder {
public:
  typedef ToCSVParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasFilename();
  inline  ::capnp::Text::Builder getFilename();
  inline void setFilename( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFilename(unsigned int size);
  inline void adoptFilename(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFilename();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ToCSVParams::Pipeline {
public:
  typedef ToCSVParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ToCSVResults::Reader {
public:
  typedef ToCSVResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ToCSVResults::Builder {
public:
  typedef ToCSVResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ToCSVResults::Pipeline {
public:
  typedef ToCSVResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ExportCellCSVParams::Reader {
public:
  typedef ExportCellCSVParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::vmtsmap::Map::Reader getMap() const;

  inline bool hasFilename() const;
  inline  ::capnp::Text::Reader getFilename() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ExportCellCSVParams::Builder {
public:
  typedef ExportCellCSVParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::vmtsmap::Map::Builder getMap();
  inline void setMap( ::vmtsmap::Map::Reader value);
  inline  ::vmtsmap::Map::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::vmtsmap::Map>&& value);
  inline ::capnp::Orphan< ::vmtsmap::Map> disownMap();

  inline bool hasFilename();
  inline  ::capnp::Text::Builder getFilename();
  inline void setFilename( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFilename(unsigned int size);
  inline void adoptFilename(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFilename();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ExportCellCSVParams::Pipeline {
public:
  typedef ExportCellCSVParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::Map::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::ExportCellCSVResults::Reader {
public:
  typedef ExportCellCSVResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::ExportCellCSVResults::Builder {
public:
  typedef ExportCellCSVResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getResult();
  inline void setResult( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::ExportCellCSVResults::Pipeline {
public:
  typedef ExportCellCSVResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GenerateParams::Reader {
public:
  typedef GenerateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GenerateParams::Builder {
public:
  typedef GenerateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GenerateParams::Pipeline {
public:
  typedef GenerateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GenerateResults::Reader {
public:
  typedef GenerateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::vmtsmap::BoxType::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GenerateResults::Builder {
public:
  typedef GenerateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::vmtsmap::BoxType::Builder getResult();
  inline void setResult( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GenerateResults::Pipeline {
public:
  typedef GenerateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetBoxParams::Reader {
public:
  typedef GetBoxParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasBox() const;
  inline  ::vmtsmap::BoxType::Reader getBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetBoxParams::Builder {
public:
  typedef GetBoxParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBox();
  inline  ::vmtsmap::BoxType::Builder getBox();
  inline void setBox( ::vmtsmap::BoxType::Reader value);
  inline  ::vmtsmap::BoxType::Builder initBox();
  inline void adoptBox(::capnp::Orphan< ::vmtsmap::BoxType>&& value);
  inline ::capnp::Orphan< ::vmtsmap::BoxType> disownBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetBoxParams::Pipeline {
public:
  typedef GetBoxParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vmtsmap::BoxType::Pipeline getBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapStruct::GetBoxResults::Reader {
public:
  typedef GetBoxResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::vmtsmap::PointFull>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapStruct::GetBoxResults::Builder {
public:
  typedef GetBoxResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder getResult();
  inline void setResult( ::capnp::List< ::vmtsmap::PointFull>::Reader value);
  inline  ::capnp::List< ::vmtsmap::PointFull>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapStruct::GetBoxResults::Pipeline {
public:
  typedef GetBoxResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint32_t Map::Reader::getCampaingID() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Map::Builder::getCampaingID() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setCampaingID( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Map::Reader::hasProvinceCode() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Map::Builder::hasProvinceCode() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Map::Reader::getProvinceCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Map::Builder::getProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Map::Builder::setProvinceCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Map::Builder::initProvinceCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Map::Builder::adoptProvinceCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Map::Builder::disownProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int64_t Map::Reader::getStartTime() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t Map::Builder::getStartTime() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setStartTime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Map::Reader::getStopTime() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t Map::Builder::getStopTime() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setStopTime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline bool Map::Reader::hasDeviceList() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Map::Builder::hasDeviceList() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader Map::Reader::getDeviceList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder Map::Builder::getDeviceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Map::Builder::setDeviceList( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void Map::Builder::setDeviceList(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder Map::Builder::initDeviceList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Map::Builder::adoptDeviceList(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> Map::Builder::disownDeviceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::uint8_t Map::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::uint8_t Map::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Map::Reader::getIndoor() const {
  return _reader.getDataField< ::int8_t>(
      5 * ::capnp::ELEMENTS);
}

inline  ::int8_t Map::Builder::getIndoor() {
  return _builder.getDataField< ::int8_t>(
      5 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setIndoor( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      5 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Map::Reader::getUeposition() const {
  return _reader.getDataField< ::int8_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int8_t Map::Builder::getUeposition() {
  return _builder.getDataField< ::int8_t>(
      6 * ::capnp::ELEMENTS);
}
inline void Map::Builder::setUeposition( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t PtLatLon::Reader::getX() const {
  return _reader.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int64_t PtLatLon::Builder::getX() {
  return _builder.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}
inline void PtLatLon::Builder::setX( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t PtLatLon::Reader::getY() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t PtLatLon::Builder::getY() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void PtLatLon::Builder::setY( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline double PointType::Reader::getX() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double PointType::Builder::getX() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void PointType::Builder::setX(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double PointType::Reader::getY() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double PointType::Builder::getY() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void PointType::Builder::setY(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline double BoxType::Reader::getTopLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double BoxType::Builder::getTopLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void BoxType::Builder::setTopLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double BoxType::Reader::getBottomLat() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double BoxType::Builder::getBottomLat() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void BoxType::Builder::setBottomLat(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline double BoxType::Reader::getTopLng() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double BoxType::Builder::getTopLng() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void BoxType::Builder::setTopLng(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline double BoxType::Reader::getBottomLng() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double BoxType::Builder::getBottomLng() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void BoxType::Builder::setBottomLng(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline double PointDataNew::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double PointDataNew::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double PointDataNew::Reader::getLon() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double PointDataNew::Builder::getLon() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setLon(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t PointDataNew::Reader::getDatetime() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t PointDataNew::Builder::getDatetime() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setDatetime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t PointDataNew::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::uint32_t PointDataNew::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointDataNew::Reader::getDevice() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointDataNew::Builder::getDevice() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setDevice( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t PointDataNew::Reader::getCellID() const {
  return _reader.getDataField< ::uint32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::uint32_t PointDataNew::Builder::getCellID() {
  return _builder.getDataField< ::uint32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setCellID( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointDataNew::Reader::getRfcn() const {
  return _reader.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointDataNew::Builder::getRfcn() {
  return _builder.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setRfcn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t PointDataNew::Reader::getRscpRssi() const {
  return _reader.getDataField< ::int16_t>(
      20 * ::capnp::ELEMENTS);
}

inline  ::int16_t PointDataNew::Builder::getRscpRssi() {
  return _builder.getDataField< ::int16_t>(
      20 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setRscpRssi( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      20 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getEcno() const {
  return _reader.getDataField< ::int8_t>(
      42 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getEcno() {
  return _builder.getDataField< ::int8_t>(
      42 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setEcno( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      42 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getCOverImin() const {
  return _reader.getDataField< ::int8_t>(
      43 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getCOverImin() {
  return _builder.getDataField< ::int8_t>(
      43 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setCOverImin( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      43 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getCOverImax() const {
  return _reader.getDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getCOverImax() {
  return _builder.getDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setCOverImax( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getCOverIavg() const {
  return _reader.getDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getCOverIavg() {
  return _builder.getDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setCOverIavg( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS, value);
}

inline bool PointDataNew::Reader::getIndoor() const {
  return _reader.getDataField<bool>(
      368 * ::capnp::ELEMENTS);
}

inline bool PointDataNew::Builder::getIndoor() {
  return _builder.getDataField<bool>(
      368 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setIndoor(bool value) {
  _builder.setDataField<bool>(
      368 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PointDataNew::Reader::getEventID() const {
  return _reader.getDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS);
}

inline  ::uint8_t PointDataNew::Builder::getEventID() {
  return _builder.getDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setEventID( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getRxqual() const {
  return _reader.getDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getRxqual() {
  return _builder.getDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setRxqual( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PointDataNew::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      49 * ::capnp::ELEMENTS);
}

inline  ::uint8_t PointDataNew::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      49 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      49 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointDataNew::Reader::getUeposition() const {
  return _reader.getDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointDataNew::Builder::getUeposition() {
  return _builder.getDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS);
}
inline void PointDataNew::Builder::setUeposition( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS, value);
}

inline bool PointDataVector::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool PointDataVector::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointDataNew>::Reader PointDataVector::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointDataNew>::Builder PointDataVector::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void PointDataVector::Builder::setData( ::capnp::List< ::vmtsmap::PointDataNew>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointDataNew>::Builder PointDataVector::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void PointDataVector::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointDataNew>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointDataNew>> PointDataVector::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointDataNew>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t PointDataVector::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointDataVector::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t PointDataVector::Reader::getCampaignID() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t PointDataVector::Builder::getCampaignID() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setCampaignID( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool PointDataVector::Reader::hasProvinceCode() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool PointDataVector::Builder::hasProvinceCode() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PointDataVector::Reader::getProvinceCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PointDataVector::Builder::getProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void PointDataVector::Builder::setProvinceCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PointDataVector::Builder::initProvinceCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void PointDataVector::Builder::adoptProvinceCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PointDataVector::Builder::disownProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::int64_t PointDataVector::Reader::getStartTime() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t PointDataVector::Builder::getStartTime() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setStartTime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t PointDataVector::Reader::getStopTime() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t PointDataVector::Builder::getStopTime() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setStopTime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline bool PointDataVector::Reader::hasDeviceList() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool PointDataVector::Builder::hasDeviceList() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader PointDataVector::Reader::getDeviceList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder PointDataVector::Builder::getDeviceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void PointDataVector::Builder::setDeviceList( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline void PointDataVector::Builder::setDeviceList(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder PointDataVector::Builder::initDeviceList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void PointDataVector::Builder::adoptDeviceList(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> PointDataVector::Builder::disownDeviceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::uint8_t PointDataVector::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      24 * ::capnp::ELEMENTS);
}

inline  ::uint8_t PointDataVector::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      24 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      24 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointDataVector::Reader::getMaxID() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointDataVector::Builder::getMaxID() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setMaxID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointDataVector::Reader::getTotalPoints() const {
  return _reader.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointDataVector::Builder::getTotalPoints() {
  return _builder.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void PointDataVector::Builder::setTotalPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Rect::Reader::getTopLat() const {
  return _reader.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int64_t Rect::Builder::getTopLat() {
  return _builder.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Rect::Builder::setTopLat( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Rect::Reader::getBottomLat() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t Rect::Builder::getBottomLat() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Rect::Builder::setBottomLat( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Rect::Reader::getTopLng() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t Rect::Builder::getTopLng() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Rect::Builder::setTopLng( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Rect::Reader::getBottomLng() const {
  return _reader.getDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int64_t Rect::Builder::getBottomLng() {
  return _builder.getDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS);
}
inline void Rect::Builder::setBottomLng( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ClusterParam::Reader::getFilterType() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t ClusterParam::Builder::getFilterType() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setFilterType( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ClusterParam::Reader::getZoomLevel() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t ClusterParam::Builder::getZoomLevel() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setZoomLevel( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline float ClusterParam::Reader::getViewPercentW() const {
  return _reader.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}

inline float ClusterParam::Builder::getViewPercentW() {
  return _builder.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setViewPercentW(float value) {
  _builder.setDataField<float>(
      2 * ::capnp::ELEMENTS, value);
}

inline float ClusterParam::Reader::getViewPercentH() const {
  return _reader.getDataField<float>(
      3 * ::capnp::ELEMENTS);
}

inline float ClusterParam::Builder::getViewPercentH() {
  return _builder.getDataField<float>(
      3 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setViewPercentH(float value) {
  _builder.setDataField<float>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ClusterParam::Reader::getMapWidthPx() const {
  return _reader.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int32_t ClusterParam::Builder::getMapWidthPx() {
  return _builder.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setMapWidthPx( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ClusterParam::Reader::getMapHeightPx() const {
  return _reader.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}

inline  ::int32_t ClusterParam::Builder::getMapHeightPx() {
  return _builder.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setMapHeightPx( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ClusterParam::Reader::getPointLimit() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t ClusterParam::Builder::getPointLimit() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void ClusterParam::Builder::setPointLimit( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Point::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Point::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Point::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::uint8_t Point::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Point::Reader::getLat() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t Point::Builder::getLat() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setLat( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Point::Reader::getLon() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t Point::Builder::getLon() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setLon( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getRscpRssi() const {
  return _reader.getDataField< ::int16_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getRscpRssi() {
  return _builder.getDataField< ::int16_t>(
      3 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setRscpRssi( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getEcno() const {
  return _reader.getDataField< ::int16_t>(
      12 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getEcno() {
  return _builder.getDataField< ::int16_t>(
      12 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setEcno( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      12 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getCOverImin() const {
  return _reader.getDataField< ::int16_t>(
      13 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getCOverImin() {
  return _builder.getDataField< ::int16_t>(
      13 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setCOverImin( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      13 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getCOverImax() const {
  return _reader.getDataField< ::int16_t>(
      14 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getCOverImax() {
  return _builder.getDataField< ::int16_t>(
      14 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setCOverImax( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      14 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Point::Reader::getDatetime() const {
  return _reader.getDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int64_t Point::Builder::getDatetime() {
  return _builder.getDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setDatetime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point::Reader::getDevice() const {
  return _reader.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int32_t Point::Builder::getDevice() {
  return _builder.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setDevice( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline bool Point::Reader::getIndoor() const {
  return _reader.getDataField<bool>(
      40 * ::capnp::ELEMENTS);
}

inline bool Point::Builder::getIndoor() {
  return _builder.getDataField<bool>(
      40 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setIndoor(bool value) {
  _builder.setDataField<bool>(
      40 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Point::Reader::getEventID() const {
  return _reader.getDataField< ::uint8_t>(
      30 * ::capnp::ELEMENTS);
}

inline  ::uint8_t Point::Builder::getEventID() {
  return _builder.getDataField< ::uint8_t>(
      30 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setEventID( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      30 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point::Reader::getCellID() const {
  return _reader.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}

inline  ::int32_t Point::Builder::getCellID() {
  return _builder.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setCellID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getRxqual() const {
  return _reader.getDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getRxqual() {
  return _builder.getDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setRxqual( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Point::Reader::getCOverIavg() const {
  return _reader.getDataField< ::int16_t>(
      25 * ::capnp::ELEMENTS);
}

inline  ::int16_t Point::Builder::getCOverIavg() {
  return _builder.getDataField< ::int16_t>(
      25 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setCOverIavg( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      25 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Point::Reader::getRfcn() const {
  return _reader.getDataField< ::int32_t>(
      13 * ::capnp::ELEMENTS);
}

inline  ::int32_t Point::Builder::getRfcn() {
  return _builder.getDataField< ::int32_t>(
      13 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setRfcn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      13 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Point::Reader::getUeposition() const {
  return _reader.getDataField< ::int8_t>(
      31 * ::capnp::ELEMENTS);
}

inline  ::int8_t Point::Builder::getUeposition() {
  return _builder.getDataField< ::int8_t>(
      31 * ::capnp::ELEMENTS);
}
inline void Point::Builder::setUeposition( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      31 * ::capnp::ELEMENTS, value);
}

inline double PointFull::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double PointFull::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double PointFull::Reader::getLon() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double PointFull::Builder::getLon() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setLon(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t PointFull::Reader::getDatetime() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t PointFull::Builder::getDatetime() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setDatetime( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t PointFull::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::uint32_t PointFull::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointFull::Reader::getDevice() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointFull::Builder::getDevice() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setDevice( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointFull::Reader::getCellID() const {
  return _reader.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointFull::Builder::getCellID() {
  return _builder.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setCellID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PointFull::Reader::getRfcn() const {
  return _reader.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int32_t PointFull::Builder::getRfcn() {
  return _builder.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRfcn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PointFull::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS);
}

inline  ::uint8_t PointFull::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t PointFull::Reader::getRscpRssi() const {
  return _reader.getDataField< ::int16_t>(
      21 * ::capnp::ELEMENTS);
}

inline  ::int16_t PointFull::Builder::getRscpRssi() {
  return _builder.getDataField< ::int16_t>(
      21 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRscpRssi( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      21 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getEcno() const {
  return _reader.getDataField< ::int8_t>(
      41 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getEcno() {
  return _builder.getDataField< ::int8_t>(
      41 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setEcno( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      41 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getCOverImin() const {
  return _reader.getDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getCOverImin() {
  return _builder.getDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setCOverImin( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      44 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getCOverImax() const {
  return _reader.getDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getCOverImax() {
  return _builder.getDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setCOverImax( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      45 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getCOverIavg() const {
  return _reader.getDataField< ::int8_t>(
      46 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getCOverIavg() {
  return _builder.getDataField< ::int8_t>(
      46 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setCOverIavg( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      46 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t PointFull::Reader::getEventID() const {
  return _reader.getDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS);
}

inline  ::uint8_t PointFull::Builder::getEventID() {
  return _builder.getDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setEventID( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      47 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxqual() const {
  return _reader.getDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxqual() {
  return _builder.getDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxqual( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      48 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev1() const {
  return _reader.getDataField< ::int8_t>(
      49 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev1() {
  return _builder.getDataField< ::int8_t>(
      49 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev1( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      49 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev2() const {
  return _reader.getDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev2() {
  return _builder.getDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev2( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      50 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev3() const {
  return _reader.getDataField< ::int8_t>(
      51 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev3() {
  return _builder.getDataField< ::int8_t>(
      51 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev3( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      51 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev4() const {
  return _reader.getDataField< ::int8_t>(
      52 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev4() {
  return _builder.getDataField< ::int8_t>(
      52 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev4( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      52 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev5() const {
  return _reader.getDataField< ::int8_t>(
      53 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev5() {
  return _builder.getDataField< ::int8_t>(
      53 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev5( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      53 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getRxlev6() const {
  return _reader.getDataField< ::int8_t>(
      54 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getRxlev6() {
  return _builder.getDataField< ::int8_t>(
      54 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setRxlev6( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      54 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t PointFull::Reader::getUeposition() const {
  return _reader.getDataField< ::int8_t>(
      55 * ::capnp::ELEMENTS);
}

inline  ::int8_t PointFull::Builder::getUeposition() {
  return _builder.getDataField< ::int8_t>(
      55 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setUeposition( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      55 * ::capnp::ELEMENTS, value);
}

inline bool PointFull::Reader::getIndoor() const {
  return _reader.getDataField<bool>(
      448 * ::capnp::ELEMENTS);
}

inline bool PointFull::Builder::getIndoor() {
  return _builder.getDataField<bool>(
      448 * ::capnp::ELEMENTS);
}
inline void PointFull::Builder::setIndoor(bool value) {
  _builder.setDataField<bool>(
      448 * ::capnp::ELEMENTS, value);
}

inline bool TileData::Reader::hasData2G() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool TileData::Builder::hasData2G() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Reader TileData::Reader::getData2G() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder TileData::Builder::getData2G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void TileData::Builder::setData2G( ::capnp::List< ::vmtsmap::PointFull>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder TileData::Builder::initData2G(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void TileData::Builder::adoptData2G(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> TileData::Builder::disownData2G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool TileData::Reader::hasData3G() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool TileData::Builder::hasData3G() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Reader TileData::Reader::getData3G() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder TileData::Builder::getData3G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void TileData::Builder::setData3G( ::capnp::List< ::vmtsmap::PointFull>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder TileData::Builder::initData3G(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void TileData::Builder::adoptData3G(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> TileData::Builder::disownData3G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool TileData::Reader::hasBb() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool TileData::Builder::hasBb() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader TileData::Reader::getBb() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder TileData::Builder::getBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline TileData::Pipeline::getBb() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TileData::Builder::setBb( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder TileData::Builder::initBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void TileData::Builder::adoptBb(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> TileData::Builder::disownBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::int32_t TileData::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t TileData::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void TileData::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t TileData::Reader::getMaxId() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t TileData::Builder::getMaxId() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void TileData::Builder::setMaxId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool MapDetailData::Reader::hasBb() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapDetailData::Builder::hasBb() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MapDetailData::Reader::getBb() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MapDetailData::Builder::getBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MapDetailData::Pipeline::getBb() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapDetailData::Builder::setBb( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MapDetailData::Builder::initBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapDetailData::Builder::adoptBb(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MapDetailData::Builder::disownBb() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t MapDetailData::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t MapDetailData::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MapDetailData::Reader::getMaxId() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t MapDetailData::Builder::getMaxId() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setMaxId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MapDetailData::Reader::getNumTiles() const {
  return _reader.getDataField< ::int8_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int8_t MapDetailData::Builder::getNumTiles() {
  return _builder.getDataField< ::int8_t>(
      8 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setNumTiles( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline double MapDetailData::Reader::getLx() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double MapDetailData::Builder::getLx() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setLx(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline double MapDetailData::Reader::getLy() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double MapDetailData::Builder::getLy() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setLy(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MapDetailData::Reader::getNROWS() const {
  return _reader.getDataField< ::int8_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int8_t MapDetailData::Builder::getNROWS() {
  return _builder.getDataField< ::int8_t>(
      9 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setNROWS( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MapDetailData::Reader::getNCOLS() const {
  return _reader.getDataField< ::int8_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int8_t MapDetailData::Builder::getNCOLS() {
  return _builder.getDataField< ::int8_t>(
      10 * ::capnp::ELEMENTS);
}
inline void MapDetailData::Builder::setNCOLS( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline bool Results::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Results::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader Results::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder Results::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Results::Builder::setData( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder Results::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Results::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> Results::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Results::Reader::hasRemains() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Results::Builder::hasRemains() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader Results::Reader::getRemains() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder Results::Builder::getRemains() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Results::Builder::setRemains( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void Results::Builder::setRemains(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder Results::Builder::initRemains(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Results::Builder::adoptRemains(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> Results::Builder::disownRemains() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Results::Reader::getLoaded() const {
  return _reader.getDataField<bool>(
      0 * ::capnp::ELEMENTS);
}

inline bool Results::Builder::getLoaded() {
  return _builder.getDataField<bool>(
      0 * ::capnp::ELEMENTS);
}
inline void Results::Builder::setLoaded(bool value) {
  _builder.setDataField<bool>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Results::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t Results::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Results::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline float AnalysisOptions::Reader::getEps() const {
  return _reader.getDataField<float>(
      0 * ::capnp::ELEMENTS);
}

inline float AnalysisOptions::Builder::getEps() {
  return _builder.getDataField<float>(
      0 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setEps(float value) {
  _builder.setDataField<float>(
      0 * ::capnp::ELEMENTS, value);
}

inline float AnalysisOptions::Reader::getMinP() const {
  return _reader.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}

inline float AnalysisOptions::Builder::getMinP() {
  return _builder.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setMinP(float value) {
  _builder.setDataField<float>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t AnalysisOptions::Reader::getDbmThreshold() const {
  return _reader.getDataField< ::int16_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int16_t AnalysisOptions::Builder::getDbmThreshold() {
  return _builder.getDataField< ::int16_t>(
      4 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setDbmThreshold( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t AnalysisOptions::Reader::getRssiThreshold() const {
  return _reader.getDataField< ::int16_t>(
      5 * ::capnp::ELEMENTS);
}

inline  ::int16_t AnalysisOptions::Builder::getRssiThreshold() {
  return _builder.getDataField< ::int16_t>(
      5 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setRssiThreshold( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      5 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t AnalysisOptions::Reader::getEcnoThreshold() const {
  return _reader.getDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int16_t AnalysisOptions::Builder::getEcnoThreshold() {
  return _builder.getDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setEcnoThreshold( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t AnalysisOptions::Reader::getLx() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t AnalysisOptions::Builder::getLx() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setLx( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t AnalysisOptions::Reader::getLy() const {
  return _reader.getDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int64_t AnalysisOptions::Builder::getLy() {
  return _builder.getDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setLy( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t AnalysisOptions::Reader::getAnalysisType() const {
  return _reader.getDataField< ::int8_t>(
      14 * ::capnp::ELEMENTS);
}

inline  ::int8_t AnalysisOptions::Builder::getAnalysisType() {
  return _builder.getDataField< ::int8_t>(
      14 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setAnalysisType( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      14 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AnalysisOptions::Reader::getOv2G() const {
  return _reader.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int32_t AnalysisOptions::Builder::getOv2G() {
  return _builder.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setOv2G( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AnalysisOptions::Reader::getOv3G() const {
  return _reader.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int32_t AnalysisOptions::Builder::getOv3G() {
  return _builder.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setOv3G( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t AnalysisOptions::Reader::getDataType() const {
  return _reader.getDataField< ::uint8_t>(
      15 * ::capnp::ELEMENTS);
}

inline  ::uint8_t AnalysisOptions::Builder::getDataType() {
  return _builder.getDataField< ::uint8_t>(
      15 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setDataType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      15 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t AnalysisOptions::Reader::getMinPts() const {
  return _reader.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int32_t AnalysisOptions::Builder::getMinPts() {
  return _builder.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setMinPts( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t AnalysisOptions::Reader::getOvExtra() const {
  return _reader.getDataField< ::uint8_t>(
      44 * ::capnp::ELEMENTS);
}

inline  ::uint8_t AnalysisOptions::Builder::getOvExtra() {
  return _builder.getDataField< ::uint8_t>(
      44 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setOvExtra( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      44 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t AnalysisOptions::Reader::getRxqualThreshold() const {
  return _reader.getDataField< ::int16_t>(
      23 * ::capnp::ELEMENTS);
}

inline  ::int16_t AnalysisOptions::Builder::getRxqualThreshold() {
  return _builder.getDataField< ::int16_t>(
      23 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setRxqualThreshold( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      23 * ::capnp::ELEMENTS, value);
}

inline bool AnalysisOptions::Reader::getViewExtra() const {
  return _reader.getDataField<bool>(
      360 * ::capnp::ELEMENTS);
}

inline bool AnalysisOptions::Builder::getViewExtra() {
  return _builder.getDataField<bool>(
      360 * ::capnp::ELEMENTS);
}
inline void AnalysisOptions::Builder::setViewExtra(bool value) {
  _builder.setDataField<bool>(
      360 * ::capnp::ELEMENTS, value);
}

inline double ResultType::Reader::getArea() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double ResultType::Builder::getArea() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setArea(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ResultType::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int32_t ResultType::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline double ResultType::Reader::getCentroidx() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double ResultType::Builder::getCentroidx() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setCentroidx(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline double ResultType::Reader::getCentroidy() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double ResultType::Builder::getCentroidy() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setCentroidy(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline double ResultType::Reader::getRadius() const {
  return _reader.getDataField<double>(
      4 * ::capnp::ELEMENTS);
}

inline double ResultType::Builder::getRadius() {
  return _builder.getDataField<double>(
      4 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ResultType::Reader::getTotalPoints() const {
  return _reader.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int32_t ResultType::Builder::getTotalPoints() {
  return _builder.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setTotalPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline bool ResultType::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ResultType::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader ResultType::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder ResultType::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ResultType::Builder::setData( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void ResultType::Builder::setData(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder ResultType::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ResultType::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> ResultType::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint8_t ResultType::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS);
}

inline  ::uint8_t ResultType::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      40 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t ResultType::Reader::getDataType() const {
  return _reader.getDataField< ::uint8_t>(
      41 * ::capnp::ELEMENTS);
}

inline  ::uint8_t ResultType::Builder::getDataType() {
  return _builder.getDataField< ::uint8_t>(
      41 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setDataType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      41 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ResultType::Reader::getMaxID() const {
  return _reader.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}

inline  ::int32_t ResultType::Builder::getMaxID() {
  return _builder.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setMaxID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ResultType::Reader::getMapNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS);
}

inline  ::int32_t ResultType::Builder::getMapNumPoints() {
  return _builder.getDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS);
}
inline void ResultType::Builder::setMapNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS, value);
}

inline bool NeighboursData::Reader::hasCellCode() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool NeighboursData::Builder::hasCellCode() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader NeighboursData::Reader::getCellCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder NeighboursData::Builder::getCellCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void NeighboursData::Builder::setCellCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder NeighboursData::Builder::initCellCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void NeighboursData::Builder::adoptCellCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> NeighboursData::Builder::disownCellCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t NeighboursData::Reader::getCount() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t NeighboursData::Builder::getCount() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setCount( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NeighboursData::Reader::getTotals() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t NeighboursData::Builder::getTotals() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setTotals( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline float NeighboursData::Reader::getPercent() const {
  return _reader.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}

inline float NeighboursData::Builder::getPercent() {
  return _builder.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setPercent(float value) {
  _builder.setDataField<float>(
      2 * ::capnp::ELEMENTS, value);
}

inline double NeighboursData::Reader::getLat() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double NeighboursData::Builder::getLat() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setLat(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline double NeighboursData::Reader::getLon() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double NeighboursData::Builder::getLon() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setLon(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t NeighboursData::Reader::getAzimuth() const {
  return _reader.getDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int16_t NeighboursData::Builder::getAzimuth() {
  return _builder.getDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS);
}
inline void NeighboursData::Builder::setAzimuth( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline bool MissingNeighbours::Reader::hasServing() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MissingNeighbours::Builder::hasServing() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MissingNeighbours::Reader::getServing() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MissingNeighbours::Builder::getServing() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MissingNeighbours::Builder::setServing( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MissingNeighbours::Builder::initServing(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MissingNeighbours::Builder::adoptServing(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MissingNeighbours::Builder::disownServing() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MissingNeighbours::Reader::hasMissing() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MissingNeighbours::Builder::hasMissing() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::NeighboursData>::Reader MissingNeighbours::Reader::getMissing() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::NeighboursData>::Builder MissingNeighbours::Builder::getMissing() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MissingNeighbours::Builder::setMissing( ::capnp::List< ::vmtsmap::NeighboursData>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::NeighboursData>::Builder MissingNeighbours::Builder::initMissing(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MissingNeighbours::Builder::adoptMissing(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::NeighboursData>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::NeighboursData>> MissingNeighbours::Builder::disownMissing() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::NeighboursData>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline double MissingNeighbours::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double MissingNeighbours::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double MissingNeighbours::Reader::getLon() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double MissingNeighbours::Builder::getLon() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setLon(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t MissingNeighbours::Reader::getAzimuth() const {
  return _reader.getDataField< ::int16_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int16_t MissingNeighbours::Builder::getAzimuth() {
  return _builder.getDataField< ::int16_t>(
      8 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setAzimuth( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MissingNeighbours::Reader::getType() const {
  return _reader.getDataField< ::int8_t>(
      18 * ::capnp::ELEMENTS);
}

inline  ::int8_t MissingNeighbours::Builder::getType() {
  return _builder.getDataField< ::int8_t>(
      18 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setType( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      18 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MissingNeighbours::Reader::getMaxID() const {
  return _reader.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}

inline  ::int32_t MissingNeighbours::Builder::getMaxID() {
  return _builder.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setMaxID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MissingNeighbours::Reader::getMapNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t MissingNeighbours::Builder::getMapNumPoints() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void MissingNeighbours::Builder::setMapNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t OverlapReport::Reader::getNumCells() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t OverlapReport::Builder::getNumCells() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void OverlapReport::Builder::setNumCells( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline float OverlapReport::Reader::getPercent() const {
  return _reader.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}

inline float OverlapReport::Builder::getPercent() {
  return _builder.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}
inline void OverlapReport::Builder::setPercent(float value) {
  _builder.setDataField<float>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool OverlapFinalReport::Reader::hasReport2G() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool OverlapFinalReport::Builder::hasReport2G() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader OverlapFinalReport::Reader::getReport2G() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder OverlapFinalReport::Builder::getReport2G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void OverlapFinalReport::Builder::setReport2G( ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void OverlapFinalReport::Builder::setReport2G(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::OverlapReport>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder OverlapFinalReport::Builder::initReport2G(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void OverlapFinalReport::Builder::adoptReport2G(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>> OverlapFinalReport::Builder::disownReport2G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool OverlapFinalReport::Reader::hasReport3G() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool OverlapFinalReport::Builder::hasReport3G() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader OverlapFinalReport::Reader::getReport3G() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder OverlapFinalReport::Builder::getReport3G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void OverlapFinalReport::Builder::setReport3G( ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void OverlapFinalReport::Builder::setReport3G(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::OverlapReport>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>::Builder OverlapFinalReport::Builder::initReport3G(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void OverlapFinalReport::Builder::adoptReport3G(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>> OverlapFinalReport::Builder::disownReport3G() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::OverlapReport>>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::int32_t OverlapFinalReport::Reader::getCampaignID() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t OverlapFinalReport::Builder::getCampaignID() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void OverlapFinalReport::Builder::setCampaignID( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool OverlapFinalReport::Reader::hasProvinceCode() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool OverlapFinalReport::Builder::hasProvinceCode() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader OverlapFinalReport::Reader::getProvinceCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder OverlapFinalReport::Builder::getProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void OverlapFinalReport::Builder::setProvinceCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder OverlapFinalReport::Builder::initProvinceCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void OverlapFinalReport::Builder::adoptProvinceCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> OverlapFinalReport::Builder::disownProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline float MissingNeighbourParam::Reader::getRSearch() const {
  return _reader.getDataField<float>(
      0 * ::capnp::ELEMENTS);
}

inline float MissingNeighbourParam::Builder::getRSearch() {
  return _builder.getDataField<float>(
      0 * ::capnp::ELEMENTS);
}
inline void MissingNeighbourParam::Builder::setRSearch(float value) {
  _builder.setDataField<float>(
      0 * ::capnp::ELEMENTS, value);
}

inline float MissingNeighbourParam::Reader::getMinOF() const {
  return _reader.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}

inline float MissingNeighbourParam::Builder::getMinOF() {
  return _builder.getDataField<float>(
      1 * ::capnp::ELEMENTS);
}
inline void MissingNeighbourParam::Builder::setMinOF(float value) {
  _builder.setDataField<float>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t FeederParams::Reader::getMinStrength2G() const {
  return _reader.getDataField< ::int16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int16_t FeederParams::Builder::getMinStrength2G() {
  return _builder.getDataField< ::int16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void FeederParams::Builder::setMinStrength2G( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t FeederParams::Reader::getMinStrength3G() const {
  return _reader.getDataField< ::int16_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int16_t FeederParams::Builder::getMinStrength3G() {
  return _builder.getDataField< ::int16_t>(
      1 * ::capnp::ELEMENTS);
}
inline void FeederParams::Builder::setMinStrength3G( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t FeederParams::Reader::getMinPts() const {
  return _reader.getDataField< ::int16_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int16_t FeederParams::Builder::getMinPts() {
  return _builder.getDataField< ::int16_t>(
      2 * ::capnp::ELEMENTS);
}
inline void FeederParams::Builder::setMinPts( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline float FeederParams::Reader::getMinR() const {
  return _reader.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}

inline float FeederParams::Builder::getMinR() {
  return _builder.getDataField<float>(
      2 * ::capnp::ELEMENTS);
}
inline void FeederParams::Builder::setMinR(float value) {
  _builder.setDataField<float>(
      2 * ::capnp::ELEMENTS, value);
}

inline float FeederParams::Reader::getMinP() const {
  return _reader.getDataField<float>(
      3 * ::capnp::ELEMENTS);
}

inline float FeederParams::Builder::getMinP() {
  return _builder.getDataField<float>(
      3 * ::capnp::ELEMENTS);
}
inline void FeederParams::Builder::setMinP(float value) {
  _builder.setDataField<float>(
      3 * ::capnp::ELEMENTS, value);
}

inline bool CellInfo::Reader::hasNeighbors() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool CellInfo::Builder::hasNeighbors() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader CellInfo::Reader::getNeighbors() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text>::Builder CellInfo::Builder::getNeighbors() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void CellInfo::Builder::setNeighbors( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void CellInfo::Builder::setNeighbors(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder CellInfo::Builder::initNeighbors(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void CellInfo::Builder::adoptNeighbors(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> CellInfo::Builder::disownNeighbors() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool CellInfo::Reader::hasCellCode() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool CellInfo::Builder::hasCellCode() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellInfo::Reader::getCellCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CellInfo::Builder::getCellCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void CellInfo::Builder::setCellCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellInfo::Builder::initCellCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void CellInfo::Builder::adoptCellCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellInfo::Builder::disownCellCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline double CellInfo::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double CellInfo::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double CellInfo::Reader::getLng() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double CellInfo::Builder::getLng() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setLng(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline float CellInfo::Reader::getPercent() const {
  return _reader.getDataField<float>(
      4 * ::capnp::ELEMENTS);
}

inline float CellInfo::Builder::getPercent() {
  return _builder.getDataField<float>(
      4 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setPercent(float value) {
  _builder.setDataField<float>(
      4 * ::capnp::ELEMENTS, value);
}

inline float CellInfo::Reader::getTilt() const {
  return _reader.getDataField<float>(
      5 * ::capnp::ELEMENTS);
}

inline float CellInfo::Builder::getTilt() {
  return _builder.getDataField<float>(
      5 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setTilt(float value) {
  _builder.setDataField<float>(
      5 * ::capnp::ELEMENTS, value);
}

inline float CellInfo::Reader::getAntennaHeightGround() const {
  return _reader.getDataField<float>(
      6 * ::capnp::ELEMENTS);
}

inline float CellInfo::Builder::getAntennaHeightGround() {
  return _builder.getDataField<float>(
      6 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setAntennaHeightGround(float value) {
  _builder.setDataField<float>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellInfo::Reader::getTotal() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellInfo::Builder::getTotal() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setTotal( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t CellInfo::Reader::getAzimuth() const {
  return _reader.getDataField< ::int16_t>(
      16 * ::capnp::ELEMENTS);
}

inline  ::int16_t CellInfo::Builder::getAzimuth() {
  return _builder.getDataField< ::int16_t>(
      16 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setAzimuth( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      16 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellInfo::Reader::getCi() const {
  return _reader.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellInfo::Builder::getCi() {
  return _builder.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setCi( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellInfo::Reader::getLac() const {
  return _reader.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellInfo::Builder::getLac() {
  return _builder.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setLac( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellInfo::Reader::getBcch() const {
  return _reader.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellInfo::Builder::getBcch() {
  return _builder.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setBcch( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellInfo::Reader::getPscBsic() const {
  return _reader.getDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellInfo::Builder::getPscBsic() {
  return _builder.getDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setPscBsic( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      12 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CellInfo::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      34 * ::capnp::ELEMENTS);
}

inline  ::uint8_t CellInfo::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      34 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      34 * ::capnp::ELEMENTS, value);
}

inline double CellInfo::Reader::getVoiceTraffic() const {
  return _reader.getDataField<double>(
      7 * ::capnp::ELEMENTS);
}

inline double CellInfo::Builder::getVoiceTraffic() {
  return _builder.getDataField<double>(
      7 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setVoiceTraffic(double value) {
  _builder.setDataField<double>(
      7 * ::capnp::ELEMENTS, value);
}

inline double CellInfo::Reader::getDataTraffic() const {
  return _reader.getDataField<double>(
      8 * ::capnp::ELEMENTS);
}

inline double CellInfo::Builder::getDataTraffic() {
  return _builder.getDataField<double>(
      8 * ::capnp::ELEMENTS);
}
inline void CellInfo::Builder::setDataTraffic(double value) {
  _builder.setDataField<double>(
      8 * ::capnp::ELEMENTS, value);
}

inline bool CellDataInfo::Reader::hasRelations() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool CellDataInfo::Builder::hasRelations() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader CellDataInfo::Reader::getRelations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text>::Builder CellDataInfo::Builder::getRelations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void CellDataInfo::Builder::setRelations( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void CellDataInfo::Builder::setRelations(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder CellDataInfo::Builder::initRelations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void CellDataInfo::Builder::adoptRelations(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> CellDataInfo::Builder::disownRelations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool CellDataInfo::Reader::hasCellName() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool CellDataInfo::Builder::hasCellName() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellDataInfo::Reader::getCellName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CellDataInfo::Builder::getCellName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void CellDataInfo::Builder::setCellName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellDataInfo::Builder::initCellName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void CellDataInfo::Builder::adoptCellName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellDataInfo::Builder::disownCellName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline double CellDataInfo::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double CellDataInfo::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double CellDataInfo::Reader::getLng() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double CellDataInfo::Builder::getLng() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setLng(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataInfo::Reader::getCi() const {
  return _reader.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataInfo::Builder::getCi() {
  return _builder.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setCi( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t CellDataInfo::Reader::getAzimuth() const {
  return _reader.getDataField< ::int16_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int16_t CellDataInfo::Builder::getAzimuth() {
  return _builder.getDataField< ::int16_t>(
      10 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setAzimuth( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CellDataInfo::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      22 * ::capnp::ELEMENTS);
}

inline  ::uint8_t CellDataInfo::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      22 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      22 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataInfo::Reader::getCellId() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataInfo::Builder::getCellId() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setCellId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataInfo::Reader::getStationHouseId() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataInfo::Builder::getStationHouseId() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setStationHouseId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline bool CellDataInfo::Reader::hasStationCode() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool CellDataInfo::Builder::hasStationCode() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellDataInfo::Reader::getStationCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CellDataInfo::Builder::getStationCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void CellDataInfo::Builder::setStationCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellDataInfo::Builder::initStationCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void CellDataInfo::Builder::adoptStationCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellDataInfo::Builder::disownStationCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline double CellDataInfo::Reader::getVoiceTraffic() const {
  return _reader.getDataField<double>(
      4 * ::capnp::ELEMENTS);
}

inline double CellDataInfo::Builder::getVoiceTraffic() {
  return _builder.getDataField<double>(
      4 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setVoiceTraffic(double value) {
  _builder.setDataField<double>(
      4 * ::capnp::ELEMENTS, value);
}

inline double CellDataInfo::Reader::getDataTraffic() const {
  return _reader.getDataField<double>(
      5 * ::capnp::ELEMENTS);
}

inline double CellDataInfo::Builder::getDataTraffic() {
  return _builder.getDataField<double>(
      5 * ::capnp::ELEMENTS);
}
inline void CellDataInfo::Builder::setDataTraffic(double value) {
  _builder.setDataField<double>(
      5 * ::capnp::ELEMENTS, value);
}

inline bool CellDataExt::Reader::hasMyRelations() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool CellDataExt::Builder::hasMyRelations() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader CellDataExt::Reader::getMyRelations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text>::Builder CellDataExt::Builder::getMyRelations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void CellDataExt::Builder::setMyRelations( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void CellDataExt::Builder::setMyRelations(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder CellDataExt::Builder::initMyRelations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void CellDataExt::Builder::adoptMyRelations(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> CellDataExt::Builder::disownMyRelations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool CellDataExt::Reader::hasStationCode() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool CellDataExt::Builder::hasStationCode() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellDataExt::Reader::getStationCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CellDataExt::Builder::getStationCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void CellDataExt::Builder::setStationCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellDataExt::Builder::initStationCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void CellDataExt::Builder::adoptStationCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellDataExt::Builder::disownStationCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline double CellDataExt::Reader::getLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double CellDataExt::Builder::getLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double CellDataExt::Reader::getLng() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double CellDataExt::Builder::getLng() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setLng(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getCi() const {
  return _reader.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getCi() {
  return _builder.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setCi( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getCellId() const {
  return _reader.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getCellId() {
  return _builder.getDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setCellId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      5 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getStationHouseId() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getStationHouseId() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setStationHouseId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline float CellDataExt::Reader::getAntennaHeightGround() const {
  return _reader.getDataField<float>(
      7 * ::capnp::ELEMENTS);
}

inline float CellDataExt::Builder::getAntennaHeightGround() {
  return _builder.getDataField<float>(
      7 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setAntennaHeightGround(float value) {
  _builder.setDataField<float>(
      7 * ::capnp::ELEMENTS, value);
}

inline float CellDataExt::Reader::getTilt() const {
  return _reader.getDataField<float>(
      8 * ::capnp::ELEMENTS);
}

inline float CellDataExt::Builder::getTilt() {
  return _builder.getDataField<float>(
      8 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setTilt(float value) {
  _builder.setDataField<float>(
      8 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getBcch() const {
  return _reader.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getBcch() {
  return _builder.getDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setBcch( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      9 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getLac() const {
  return _reader.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getLac() {
  return _builder.getDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setLac( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t CellDataExt::Reader::getPscBsic() const {
  return _reader.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}

inline  ::int32_t CellDataExt::Builder::getPscBsic() {
  return _builder.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setPscBsic( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS, value);
}

inline  ::int16_t CellDataExt::Reader::getAzimuth() const {
  return _reader.getDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS);
}

inline  ::int16_t CellDataExt::Builder::getAzimuth() {
  return _builder.getDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setAzimuth( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      24 * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CellDataExt::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      50 * ::capnp::ELEMENTS);
}

inline  ::uint8_t CellDataExt::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      50 * ::capnp::ELEMENTS);
}
inline void CellDataExt::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      50 * ::capnp::ELEMENTS, value);
}

inline bool CellDataExt::Reader::hasCode() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool CellDataExt::Builder::hasCode() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellDataExt::Reader::getCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CellDataExt::Builder::getCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void CellDataExt::Builder::setCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellDataExt::Builder::initCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void CellDataExt::Builder::adoptCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellDataExt::Builder::disownCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::uint32_t AddSignalMsg2::Reader::getCampaignID() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t AddSignalMsg2::Builder::getCampaignID() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void AddSignalMsg2::Builder::setCampaignID( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool AddSignalMsg2::Reader::hasProvinceCode() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool AddSignalMsg2::Builder::hasProvinceCode() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AddSignalMsg2::Reader::getProvinceCode() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AddSignalMsg2::Builder::getProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void AddSignalMsg2::Builder::setProvinceCode( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AddSignalMsg2::Builder::initProvinceCode(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void AddSignalMsg2::Builder::adoptProvinceCode(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AddSignalMsg2::Builder::disownProvinceCode() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint32_t AddSignalMsg2::Reader::getStartId() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t AddSignalMsg2::Builder::getStartId() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void AddSignalMsg2::Builder::setStartId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool AddSignalMsg2::Reader::hasRows() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool AddSignalMsg2::Builder::hasRows() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Reader AddSignalMsg2::Reader::getRows() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder AddSignalMsg2::Builder::getRows() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void AddSignalMsg2::Builder::setRows( ::capnp::List< ::vmtsmap::PointFull>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder AddSignalMsg2::Builder::initRows(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void AddSignalMsg2::Builder::adoptRows(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> AddSignalMsg2::Builder::disownRows() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool DeleteSignalMsg2::Reader::hasPoly() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool DeleteSignalMsg2::Builder::hasPoly() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointType>::Reader DeleteSignalMsg2::Reader::getPoly() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointType>::Builder DeleteSignalMsg2::Builder::getPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void DeleteSignalMsg2::Builder::setPoly( ::capnp::List< ::vmtsmap::PointType>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointType>::Builder DeleteSignalMsg2::Builder::initPoly(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void DeleteSignalMsg2::Builder::adoptPoly(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>> DeleteSignalMsg2::Builder::disownPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool DeleteSignalMsg2::Reader::hasVDeleted() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool DeleteSignalMsg2::Builder::hasVDeleted() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader DeleteSignalMsg2::Reader::getVDeleted() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder DeleteSignalMsg2::Builder::getVDeleted() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void DeleteSignalMsg2::Builder::setVDeleted( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void DeleteSignalMsg2::Builder::setVDeleted(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder DeleteSignalMsg2::Builder::initVDeleted(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void DeleteSignalMsg2::Builder::adoptVDeleted(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> DeleteSignalMsg2::Builder::disownVDeleted() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::int32_t SignalCellExtra::Reader::getBsic() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCellExtra::Builder::getBsic() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void SignalCellExtra::Builder::setBsic( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCellExtra::Reader::getLac() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCellExtra::Builder::getLac() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void SignalCellExtra::Builder::setLac( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCellExtra::Reader::getArfcn() const {
  return _reader.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCellExtra::Builder::getArfcn() {
  return _builder.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void SignalCellExtra::Builder::setArfcn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCellExtra::Reader::getCirnc() const {
  return _reader.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCellExtra::Builder::getCirnc() {
  return _builder.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void SignalCellExtra::Builder::setCirnc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCell::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCell::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline double SignalCell::Reader::getLat() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double SignalCell::Builder::getLat() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setLat(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline double SignalCell::Reader::getLng() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double SignalCell::Builder::getLng() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setLng(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCell::Reader::getSc() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCell::Builder::getSc() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setSc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCell::Reader::getLac() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCell::Builder::getLac() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setLac( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCell::Reader::getCirnc() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCell::Builder::getCirnc() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setCirnc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCell::Reader::getRfcn() const {
  return _reader.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCell::Builder::getRfcn() {
  return _builder.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setRfcn( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline bool SignalCell::Reader::hasNbData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool SignalCell::Builder::hasNbData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Reader SignalCell::Reader::getNbData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Builder SignalCell::Builder::getNbData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void SignalCell::Builder::setNbData( ::capnp::List< ::vmtsmap::SignalCellExtra>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::SignalCellExtra>::Builder SignalCell::Builder::initNbData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void SignalCell::Builder::adoptNbData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCellExtra>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCellExtra>> SignalCell::Builder::disownNbData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCellExtra>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int8_t SignalCell::Reader::getType() const {
  return _reader.getDataField< ::int8_t>(
      36 * ::capnp::ELEMENTS);
}

inline  ::int8_t SignalCell::Builder::getType() {
  return _builder.getDataField< ::int8_t>(
      36 * ::capnp::ELEMENTS);
}
inline void SignalCell::Builder::setType( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      36 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCells::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCells::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void SignalCells::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t SignalCells::Reader::getMaxId() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t SignalCells::Builder::getMaxId() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void SignalCells::Builder::setMaxId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool SignalCells::Reader::hasData() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool SignalCells::Builder::hasData() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::SignalCell>::Reader SignalCells::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::SignalCell>::Builder SignalCells::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void SignalCells::Builder::setData( ::capnp::List< ::vmtsmap::SignalCell>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::SignalCell>::Builder SignalCells::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void SignalCells::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCell>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::SignalCell>> SignalCells::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::SignalCell>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline double MetaDataEntry::Reader::getTopLat() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double MetaDataEntry::Builder::getTopLat() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void MetaDataEntry::Builder::setTopLat(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline double MetaDataEntry::Reader::getBottomLat() const {
  return _reader.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}

inline double MetaDataEntry::Builder::getBottomLat() {
  return _builder.getDataField<double>(
      1 * ::capnp::ELEMENTS);
}
inline void MetaDataEntry::Builder::setBottomLat(double value) {
  _builder.setDataField<double>(
      1 * ::capnp::ELEMENTS, value);
}

inline double MetaDataEntry::Reader::getTopLng() const {
  return _reader.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}

inline double MetaDataEntry::Builder::getTopLng() {
  return _builder.getDataField<double>(
      2 * ::capnp::ELEMENTS);
}
inline void MetaDataEntry::Builder::setTopLng(double value) {
  _builder.setDataField<double>(
      2 * ::capnp::ELEMENTS, value);
}

inline double MetaDataEntry::Reader::getBottomLng() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double MetaDataEntry::Builder::getBottomLng() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void MetaDataEntry::Builder::setBottomLng(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MetaDataEntry::Reader::getNumPoints() const {
  return _reader.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}

inline  ::int32_t MetaDataEntry::Builder::getNumPoints() {
  return _builder.getDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS);
}
inline void MetaDataEntry::Builder::setNumPoints( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      8 * ::capnp::ELEMENTS, value);
}

inline bool MetaDataEntry::Reader::hasFilename() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MetaDataEntry::Builder::hasFilename() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MetaDataEntry::Reader::getFilename() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MetaDataEntry::Builder::getFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MetaDataEntry::Builder::setFilename( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MetaDataEntry::Builder::initFilename(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MetaDataEntry::Builder::adoptFilename(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MetaDataEntry::Builder::disownFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MetaData::Reader::hasBox() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MetaData::Builder::hasBox() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MetaData::Reader::getBox() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MetaData::Builder::getBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MetaData::Pipeline::getBox() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MetaData::Builder::setBox( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MetaData::Builder::initBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MetaData::Builder::adoptBox(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MetaData::Builder::disownBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MetaData::Reader::hasData() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MetaData::Builder::hasData() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Reader MetaData::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Builder MetaData::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MetaData::Builder::setData( ::capnp::List< ::vmtsmap::MetaDataEntry>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::MetaDataEntry>::Builder MetaData::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MetaData::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::MetaDataEntry>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MetaDataEntry>> MetaData::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MetaDataEntry>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline MapStruct::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline MapStruct::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline MapStruct::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline MapStruct::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline MapStruct::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::vmtsmap::MapStruct::Client& MapStruct::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::vmtsmap::MapStruct::Client& MapStruct::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool MapStruct::InsertToMapParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertToMapParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::InsertToMapParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::InsertToMapParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::InsertToMapParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::InsertToMapParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::InsertToMapParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::InsertToMapParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::InsertToMapParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertToMapParams::Reader::hasRect() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertToMapParams::Builder::hasRect() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Rect::Reader MapStruct::InsertToMapParams::Reader::getRect() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Rect::Builder MapStruct::InsertToMapParams::Builder::getRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Rect::Pipeline MapStruct::InsertToMapParams::Pipeline::getRect() {
  return  ::vmtsmap::Rect::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::InsertToMapParams::Builder::setRect( ::vmtsmap::Rect::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Rect::Builder MapStruct::InsertToMapParams::Builder::initRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::InsertToMapParams::Builder::adoptRect(
    ::capnp::Orphan< ::vmtsmap::Rect>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Rect> MapStruct::InsertToMapParams::Builder::disownRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertToMapParams::Reader::hasData() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertToMapParams::Builder::hasData() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader MapStruct::InsertToMapParams::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::InsertToMapParams::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::InsertToMapParams::Builder::setData( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::InsertToMapParams::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void MapStruct::InsertToMapParams::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> MapStruct::InsertToMapParams::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::InsertToMapResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::InsertToMapResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::InsertToMapResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::GetPointsParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPointsParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::GetPointsParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::GetPointsParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::GetPointsParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPointsParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::GetPointsParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetPointsParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::GetPointsParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPointsParams::Reader::hasRect() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPointsParams::Builder::hasRect() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Rect::Reader MapStruct::GetPointsParams::Reader::getRect() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Rect::Builder MapStruct::GetPointsParams::Builder::getRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Rect::Pipeline MapStruct::GetPointsParams::Pipeline::getRect() {
  return  ::vmtsmap::Rect::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPointsParams::Builder::setRect( ::vmtsmap::Rect::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Rect::Builder MapStruct::GetPointsParams::Builder::initRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::GetPointsParams::Builder::adoptRect(
    ::capnp::Orphan< ::vmtsmap::Rect>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Rect> MapStruct::GetPointsParams::Builder::disownRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPointsParams::Reader::hasExtra() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPointsParams::Builder::hasExtra() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ClusterParam::Reader MapStruct::GetPointsParams::Reader::getExtra() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetPointsParams::Builder::getExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ClusterParam::Pipeline MapStruct::GetPointsParams::Pipeline::getExtra() {
  return  ::vmtsmap::ClusterParam::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPointsParams::Builder::setExtra( ::vmtsmap::ClusterParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetPointsParams::Builder::initExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::GetPointsParams::Builder::adoptExtra(
    ::capnp::Orphan< ::vmtsmap::ClusterParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ClusterParam> MapStruct::GetPointsParams::Builder::disownExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPointsResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPointsResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Results::Reader MapStruct::GetPointsResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Results>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Results::Builder MapStruct::GetPointsResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Results>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Results::Pipeline MapStruct::GetPointsResults::Pipeline::getResult() {
  return  ::vmtsmap::Results::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPointsResults::Builder::setResult( ::vmtsmap::Results::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Results>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Results::Builder MapStruct::GetPointsResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Results>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetPointsResults::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::Results>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Results>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Results> MapStruct::GetPointsResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Results>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertPointsInPolygonParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertPointsInPolygonParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::InsertPointsInPolygonParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::InsertPointsInPolygonParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::InsertPointsInPolygonParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::InsertPointsInPolygonParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::InsertPointsInPolygonParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::InsertPointsInPolygonParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertPointsInPolygonParams::Reader::hasPolygons() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertPointsInPolygonParams::Builder::hasPolygons() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader MapStruct::InsertPointsInPolygonParams::Reader::getPolygons() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder MapStruct::InsertPointsInPolygonParams::Builder::getPolygons() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::setPolygons( ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::setPolygons(::kj::ArrayPtr<const  ::capnp::List< ::vmtsmap::PtLatLon>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>::Builder MapStruct::InsertPointsInPolygonParams::Builder::initPolygons(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::adoptPolygons(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>> MapStruct::InsertPointsInPolygonParams::Builder::disownPolygons() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::vmtsmap::PtLatLon>>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertPointsInPolygonParams::Reader::hasData() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertPointsInPolygonParams::Builder::hasData() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader MapStruct::InsertPointsInPolygonParams::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::InsertPointsInPolygonParams::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::setData( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::InsertPointsInPolygonParams::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> MapStruct::InsertPointsInPolygonParams::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertPointsInPolygonParams::Reader::getStrictWithin() const {
  return _reader.getDataField<bool>(
      0 * ::capnp::ELEMENTS);
}

inline bool MapStruct::InsertPointsInPolygonParams::Builder::getStrictWithin() {
  return _builder.getDataField<bool>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::InsertPointsInPolygonParams::Builder::setStrictWithin(bool value) {
  _builder.setDataField<bool>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MapStruct::InsertPointsInPolygonResults::Reader::getResult() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t MapStruct::InsertPointsInPolygonResults::Builder::getResult() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::InsertPointsInPolygonResults::Builder::setResult( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::AnalyzeParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::AnalyzeParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::AnalyzeParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::AnalyzeParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::AnalyzeParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::AnalyzeParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::AnalyzeParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::AnalyzeParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::AnalyzeParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::AnalyzeParams::Reader::hasRect() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::AnalyzeParams::Builder::hasRect() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Rect::Reader MapStruct::AnalyzeParams::Reader::getRect() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Rect::Builder MapStruct::AnalyzeParams::Builder::getRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Rect::Pipeline MapStruct::AnalyzeParams::Pipeline::getRect() {
  return  ::vmtsmap::Rect::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::AnalyzeParams::Builder::setRect( ::vmtsmap::Rect::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Rect::Builder MapStruct::AnalyzeParams::Builder::initRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::AnalyzeParams::Builder::adoptRect(
    ::capnp::Orphan< ::vmtsmap::Rect>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Rect> MapStruct::AnalyzeParams::Builder::disownRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::AnalyzeParams::Reader::hasOptions() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::AnalyzeParams::Builder::hasOptions() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::AnalyzeParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::AnalyzeParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::AnalyzeParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::AnalyzeParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::AnalyzeParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::AnalyzeParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::AnalyzeParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::AnalyzeResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::AnalyzeResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Reader MapStruct::AnalyzeResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Builder MapStruct::AnalyzeResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::AnalyzeResults::Builder::setResult( ::capnp::List< ::vmtsmap::ResultType>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Builder MapStruct::AnalyzeResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::AnalyzeResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>> MapStruct::AnalyzeResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ReportParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ReportParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ReportParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportParams::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportParams::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::ReportParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::ReportParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::ReportParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::ReportParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::OverlapFinalReport::Reader MapStruct::ReportResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::OverlapFinalReport::Pipeline MapStruct::ReportResults::Pipeline::getResult() {
  return  ::vmtsmap::OverlapFinalReport::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportResults::Builder::setResult( ::vmtsmap::OverlapFinalReport::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportResults::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> MapStruct::ReportResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportDoneParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportDoneParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ReportDoneParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportDoneParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ReportDoneParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportDoneParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportDoneParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportDoneParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ReportDoneParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::ReportDoneResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::ReportDoneResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::ReportDoneResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::QueryPolygonParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygonParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::QueryPolygonParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::QueryPolygonParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::QueryPolygonParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::QueryPolygonParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::QueryPolygonParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygonParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::QueryPolygonParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryPolygonParams::Reader::hasPoly() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygonParams::Builder::hasPoly() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader MapStruct::QueryPolygonParams::Reader::getPoly() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::QueryPolygonParams::Builder::getPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygonParams::Builder::setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::QueryPolygonParams::Builder::initPoly(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::QueryPolygonParams::Builder::adoptPoly(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> MapStruct::QueryPolygonParams::Builder::disownPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryPolygonResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygonResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader MapStruct::QueryPolygonResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::QueryPolygonResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygonResults::Builder::setResult( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::QueryPolygonResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::QueryPolygonResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> MapStruct::QueryPolygonResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::MissingNeiboursParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::MissingNeiboursParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::MissingNeiboursParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::MissingNeiboursParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::MissingNeiboursParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::MissingNeiboursParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::MissingNeiboursParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::MissingNeiboursParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::MissingNeiboursParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::MissingNeiboursParams::Reader::hasRect() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::MissingNeiboursParams::Builder::hasRect() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Rect::Reader MapStruct::MissingNeiboursParams::Reader::getRect() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Rect::Builder MapStruct::MissingNeiboursParams::Builder::getRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Rect::Pipeline MapStruct::MissingNeiboursParams::Pipeline::getRect() {
  return  ::vmtsmap::Rect::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::MissingNeiboursParams::Builder::setRect( ::vmtsmap::Rect::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Rect::Builder MapStruct::MissingNeiboursParams::Builder::initRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::MissingNeiboursParams::Builder::adoptRect(
    ::capnp::Orphan< ::vmtsmap::Rect>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Rect> MapStruct::MissingNeiboursParams::Builder::disownRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::MissingNeiboursParams::Reader::hasOptions() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::MissingNeiboursParams::Builder::hasOptions() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::MissingNeiboursParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::MissingNeiboursParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::MissingNeiboursParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::MissingNeiboursParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::MissingNeiboursParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::MissingNeiboursParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::MissingNeiboursParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::MissingNeiboursParams::Reader::hasParam() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::MissingNeiboursParams::Builder::hasParam() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::MissingNeighbourParam::Reader MapStruct::MissingNeiboursParams::Reader::getParam() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::MissingNeiboursParams::Builder::getParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::MissingNeighbourParam::Pipeline MapStruct::MissingNeiboursParams::Pipeline::getParam() {
  return  ::vmtsmap::MissingNeighbourParam::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MapStruct::MissingNeiboursParams::Builder::setParam( ::vmtsmap::MissingNeighbourParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::MissingNeiboursParams::Builder::initParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void MapStruct::MissingNeiboursParams::Builder::adoptParam(
    ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> MapStruct::MissingNeiboursParams::Builder::disownParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool MapStruct::MissingNeiboursResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::MissingNeiboursResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader MapStruct::MissingNeiboursResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::MissingNeiboursResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::MissingNeiboursResults::Builder::setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::MissingNeiboursResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::MissingNeiboursResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> MapStruct::MissingNeiboursResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighboursParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighboursParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::FindMissingNeighboursParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::FindMissingNeighboursParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::FindMissingNeighboursParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighboursParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::FindMissingNeighboursParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighboursParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::FindMissingNeighboursParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighboursParams::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighboursParams::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::FindMissingNeighboursParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindMissingNeighboursParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::FindMissingNeighboursParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighboursParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindMissingNeighboursParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighboursParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::FindMissingNeighboursParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighboursParams::Reader::hasParam() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighboursParams::Builder::hasParam() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::MissingNeighbourParam::Reader MapStruct::FindMissingNeighboursParams::Reader::getParam() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::FindMissingNeighboursParams::Builder::getParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::MissingNeighbourParam::Pipeline MapStruct::FindMissingNeighboursParams::Pipeline::getParam() {
  return  ::vmtsmap::MissingNeighbourParam::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighboursParams::Builder::setParam( ::vmtsmap::MissingNeighbourParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::FindMissingNeighboursParams::Builder::initParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighboursParams::Builder::adoptParam(
    ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> MapStruct::FindMissingNeighboursParams::Builder::disownParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighboursParams::Reader::hasArea() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighboursParams::Builder::hasArea() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ResultType::Reader MapStruct::FindMissingNeighboursParams::Reader::getArea() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindMissingNeighboursParams::Builder::getArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ResultType::Pipeline MapStruct::FindMissingNeighboursParams::Pipeline::getArea() {
  return  ::vmtsmap::ResultType::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighboursParams::Builder::setArea( ::vmtsmap::ResultType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindMissingNeighboursParams::Builder::initArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighboursParams::Builder::adoptArea(
    ::capnp::Orphan< ::vmtsmap::ResultType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ResultType> MapStruct::FindMissingNeighboursParams::Builder::disownArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighboursResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighboursResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader MapStruct::FindMissingNeighboursResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::FindMissingNeighboursResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighboursResults::Builder::setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::FindMissingNeighboursResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::FindMissingNeighboursResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> MapStruct::FindMissingNeighboursResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeedersParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeedersParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::FindSwappedFeedersParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::FindSwappedFeedersParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::FindSwappedFeedersParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeedersParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::FindSwappedFeedersParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeedersParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::FindSwappedFeedersParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeedersParams::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeedersParams::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::FindSwappedFeedersParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindSwappedFeedersParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::FindSwappedFeedersParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeedersParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindSwappedFeedersParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeedersParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::FindSwappedFeedersParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeedersParams::Reader::hasParam() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeedersParams::Builder::hasParam() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::FeederParams::Reader MapStruct::FindSwappedFeedersParams::Reader::getParam() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::FeederParams::Builder MapStruct::FindSwappedFeedersParams::Builder::getParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::FeederParams::Pipeline MapStruct::FindSwappedFeedersParams::Pipeline::getParam() {
  return  ::vmtsmap::FeederParams::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeedersParams::Builder::setParam( ::vmtsmap::FeederParams::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::FeederParams::Builder MapStruct::FindSwappedFeedersParams::Builder::initParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeedersParams::Builder::adoptParam(
    ::capnp::Orphan< ::vmtsmap::FeederParams>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::FeederParams> MapStruct::FindSwappedFeedersParams::Builder::disownParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeedersParams::Reader::hasArea() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeedersParams::Builder::hasArea() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ResultType::Reader MapStruct::FindSwappedFeedersParams::Reader::getArea() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindSwappedFeedersParams::Builder::getArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ResultType::Pipeline MapStruct::FindSwappedFeedersParams::Pipeline::getArea() {
  return  ::vmtsmap::ResultType::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeedersParams::Builder::setArea( ::vmtsmap::ResultType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindSwappedFeedersParams::Builder::initArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeedersParams::Builder::adoptArea(
    ::capnp::Orphan< ::vmtsmap::ResultType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ResultType> MapStruct::FindSwappedFeedersParams::Builder::disownArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeedersResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeedersResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Reader MapStruct::FindSwappedFeedersResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder MapStruct::FindSwappedFeedersResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeedersResults::Builder::setResult( ::capnp::List< ::vmtsmap::CellInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder MapStruct::FindSwappedFeedersResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::FindSwappedFeedersResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>> MapStruct::FindSwappedFeedersResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::NotifyParams::Reader::hasText() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::NotifyParams::Builder::hasText() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::NotifyParams::Reader::getText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::NotifyParams::Builder::getText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::NotifyParams::Builder::setText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::NotifyParams::Builder::initText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::NotifyParams::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::NotifyParams::Builder::disownText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::NotifyResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::NotifyResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::NotifyResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::NotifyResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::NotifyResults::Builder::setResult( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::NotifyResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::NotifyResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::NotifyResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::CacheMapParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::CacheMapParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::CacheMapParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::CacheMapParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::CacheMapParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::CacheMapParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::CacheMapParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::CacheMapParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::CacheMapParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::CacheMapResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::CacheMapResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::CacheMapResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::GetPoints2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPoints2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::GetPoints2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::GetPoints2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::GetPoints2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPoints2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::GetPoints2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetPoints2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::GetPoints2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPoints2Params::Reader::hasRect() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPoints2Params::Builder::hasRect() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Rect::Reader MapStruct::GetPoints2Params::Reader::getRect() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Rect::Builder MapStruct::GetPoints2Params::Builder::getRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Rect::Pipeline MapStruct::GetPoints2Params::Pipeline::getRect() {
  return  ::vmtsmap::Rect::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPoints2Params::Builder::setRect( ::vmtsmap::Rect::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Rect::Builder MapStruct::GetPoints2Params::Builder::initRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::GetPoints2Params::Builder::adoptRect(
    ::capnp::Orphan< ::vmtsmap::Rect>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Rect> MapStruct::GetPoints2Params::Builder::disownRect() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Rect>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPoints2Params::Reader::hasExtra() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPoints2Params::Builder::hasExtra() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ClusterParam::Reader MapStruct::GetPoints2Params::Reader::getExtra() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetPoints2Params::Builder::getExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ClusterParam::Pipeline MapStruct::GetPoints2Params::Pipeline::getExtra() {
  return  ::vmtsmap::ClusterParam::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetPoints2Params::Builder::setExtra( ::vmtsmap::ClusterParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetPoints2Params::Builder::initExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::GetPoints2Params::Builder::adoptExtra(
    ::capnp::Orphan< ::vmtsmap::ClusterParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ClusterParam> MapStruct::GetPoints2Params::Builder::disownExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::GetPoints2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetPoints2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader MapStruct::GetPoints2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::GetPoints2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetPoints2Results::Builder::setResult( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::GetPoints2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::GetPoints2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> MapStruct::GetPoints2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryPolygon2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygon2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::QueryPolygon2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::QueryPolygon2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::QueryPolygon2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::QueryPolygon2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::QueryPolygon2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygon2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::QueryPolygon2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryPolygon2Params::Reader::hasPoly() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygon2Params::Builder::hasPoly() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader MapStruct::QueryPolygon2Params::Reader::getPoly() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::QueryPolygon2Params::Builder::getPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygon2Params::Builder::setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::QueryPolygon2Params::Builder::initPoly(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::QueryPolygon2Params::Builder::adoptPoly(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> MapStruct::QueryPolygon2Params::Builder::disownPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryPolygon2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryPolygon2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::Point>::Reader MapStruct::QueryPolygon2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::QueryPolygon2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryPolygon2Results::Builder::setResult( ::capnp::List< ::vmtsmap::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::Point>::Builder MapStruct::QueryPolygon2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::QueryPolygon2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::Point>> MapStruct::QueryPolygon2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::Point>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetClusteredPointsParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetClusteredPointsParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::GetClusteredPointsParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::GetClusteredPointsParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::GetClusteredPointsParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetClusteredPointsParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::GetClusteredPointsParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetClusteredPointsParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::GetClusteredPointsParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetClusteredPointsParams::Reader::hasBox() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetClusteredPointsParams::Builder::hasBox() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MapStruct::GetClusteredPointsParams::Reader::getBox() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GetClusteredPointsParams::Builder::getBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MapStruct::GetClusteredPointsParams::Pipeline::getBox() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetClusteredPointsParams::Builder::setBox( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GetClusteredPointsParams::Builder::initBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::GetClusteredPointsParams::Builder::adoptBox(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MapStruct::GetClusteredPointsParams::Builder::disownBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::GetClusteredPointsParams::Reader::hasExtra() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetClusteredPointsParams::Builder::hasExtra() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ClusterParam::Reader MapStruct::GetClusteredPointsParams::Reader::getExtra() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetClusteredPointsParams::Builder::getExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ClusterParam::Pipeline MapStruct::GetClusteredPointsParams::Pipeline::getExtra() {
  return  ::vmtsmap::ClusterParam::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetClusteredPointsParams::Builder::setExtra( ::vmtsmap::ClusterParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ClusterParam::Builder MapStruct::GetClusteredPointsParams::Builder::initExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::GetClusteredPointsParams::Builder::adoptExtra(
    ::capnp::Orphan< ::vmtsmap::ClusterParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ClusterParam> MapStruct::GetClusteredPointsParams::Builder::disownExtra() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ClusterParam>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::GetClusteredPointsResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetClusteredPointsResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::PointDataVector::Reader MapStruct::GetClusteredPointsResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::PointDataVector::Builder MapStruct::GetClusteredPointsResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::PointDataVector::Pipeline MapStruct::GetClusteredPointsResults::Pipeline::getResult() {
  return  ::vmtsmap::PointDataVector::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetClusteredPointsResults::Builder::setResult( ::vmtsmap::PointDataVector::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::PointDataVector::Builder MapStruct::GetClusteredPointsResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetClusteredPointsResults::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::PointDataVector>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::PointDataVector> MapStruct::GetClusteredPointsResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::PointDataVector>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Analyze2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Analyze2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::Analyze2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::Analyze2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::Analyze2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::Analyze2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::Analyze2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Analyze2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::Analyze2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Analyze2Params::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Analyze2Params::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::Analyze2Params::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::Analyze2Params::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::Analyze2Params::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::Analyze2Params::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::Analyze2Params::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::Analyze2Params::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::Analyze2Params::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::Analyze2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Analyze2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Reader MapStruct::Analyze2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Builder MapStruct::Analyze2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Analyze2Results::Builder::setResult( ::capnp::List< ::vmtsmap::ResultType>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::ResultType>::Builder MapStruct::Analyze2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::Analyze2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::ResultType>> MapStruct::Analyze2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::ResultType>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Report2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Report2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::Report2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::Report2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::Report2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::Report2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::Report2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Report2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::Report2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Report2Params::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Report2Params::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::Report2Params::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::Report2Params::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::Report2Params::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::Report2Params::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::Report2Params::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::Report2Params::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::Report2Params::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::Report2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Report2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::OverlapFinalReport::Reader MapStruct::Report2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::Report2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::OverlapFinalReport::Pipeline MapStruct::Report2Results::Pipeline::getResult() {
  return  ::vmtsmap::OverlapFinalReport::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::Report2Results::Builder::setResult( ::vmtsmap::OverlapFinalReport::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::Report2Results::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Report2Results::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> MapStruct::Report2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Notify2Params::Reader::hasText() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Notify2Params::Builder::hasText() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::Notify2Params::Reader::getText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::Notify2Params::Builder::getText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Notify2Params::Builder::setText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::Notify2Params::Builder::initText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::Notify2Params::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::Notify2Params::Builder::disownText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::Notify2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::Notify2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::Notify2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::Notify2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::Notify2Results::Builder::setResult( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::Notify2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::Notify2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::Notify2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::CacheMap2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::CacheMap2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::CacheMap2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::CacheMap2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::CacheMap2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::CacheMap2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::CacheMap2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::CacheMap2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::CacheMap2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::CacheMap2Results::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::CacheMap2Results::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::CacheMap2Results::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::ReportPolyParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPolyParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ReportPolyParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportPolyParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ReportPolyParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPolyParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportPolyParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPolyParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ReportPolyParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPolyParams::Reader::hasPoly() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPolyParams::Builder::hasPoly() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Reader MapStruct::ReportPolyParams::Reader::getPoly() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::ReportPolyParams::Builder::getPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPolyParams::Builder::setPoly( ::capnp::List< ::vmtsmap::PtLatLon>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PtLatLon>::Builder MapStruct::ReportPolyParams::Builder::initPoly(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::ReportPolyParams::Builder::adoptPoly(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PtLatLon>> MapStruct::ReportPolyParams::Builder::disownPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PtLatLon>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPolyParams::Reader::hasOptions() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPolyParams::Builder::hasOptions() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::ReportPolyParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportPolyParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::ReportPolyParams::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPolyParams::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportPolyParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPolyParams::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::ReportPolyParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPolyResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPolyResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::OverlapFinalReport::Reader MapStruct::ReportPolyResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportPolyResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::OverlapFinalReport::Pipeline MapStruct::ReportPolyResults::Pipeline::getResult() {
  return  ::vmtsmap::OverlapFinalReport::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPolyResults::Builder::setResult( ::vmtsmap::OverlapFinalReport::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportPolyResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPolyResults::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> MapStruct::ReportPolyResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPoly2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPoly2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ReportPoly2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportPoly2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ReportPoly2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPoly2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ReportPoly2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPoly2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ReportPoly2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPoly2Params::Reader::hasPoly() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPoly2Params::Builder::hasPoly() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointType>::Reader MapStruct::ReportPoly2Params::Reader::getPoly() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointType>::Builder MapStruct::ReportPoly2Params::Builder::getPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPoly2Params::Builder::setPoly( ::capnp::List< ::vmtsmap::PointType>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointType>::Builder MapStruct::ReportPoly2Params::Builder::initPoly(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::ReportPoly2Params::Builder::adoptPoly(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointType>> MapStruct::ReportPoly2Params::Builder::disownPoly() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointType>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPoly2Params::Reader::hasOptions() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPoly2Params::Builder::hasOptions() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::ReportPoly2Params::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportPoly2Params::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::ReportPoly2Params::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPoly2Params::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::ReportPoly2Params::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPoly2Params::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::ReportPoly2Params::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::ReportPoly2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ReportPoly2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::OverlapFinalReport::Reader MapStruct::ReportPoly2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportPoly2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::OverlapFinalReport::Pipeline MapStruct::ReportPoly2Results::Pipeline::getResult() {
  return  ::vmtsmap::OverlapFinalReport::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ReportPoly2Results::Builder::setResult( ::vmtsmap::OverlapFinalReport::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::OverlapFinalReport::Builder MapStruct::ReportPoly2Results::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ReportPoly2Results::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::OverlapFinalReport>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::OverlapFinalReport> MapStruct::ReportPoly2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::OverlapFinalReport>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighbours2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighbours2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::FindMissingNeighbours2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::FindMissingNeighbours2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::FindMissingNeighbours2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighbours2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::FindMissingNeighbours2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighbours2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::FindMissingNeighbours2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighbours2Params::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighbours2Params::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::FindMissingNeighbours2Params::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindMissingNeighbours2Params::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::FindMissingNeighbours2Params::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighbours2Params::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindMissingNeighbours2Params::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighbours2Params::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::FindMissingNeighbours2Params::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighbours2Params::Reader::hasParam() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighbours2Params::Builder::hasParam() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::MissingNeighbourParam::Reader MapStruct::FindMissingNeighbours2Params::Reader::getParam() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::FindMissingNeighbours2Params::Builder::getParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::MissingNeighbourParam::Pipeline MapStruct::FindMissingNeighbours2Params::Pipeline::getParam() {
  return  ::vmtsmap::MissingNeighbourParam::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighbours2Params::Builder::setParam( ::vmtsmap::MissingNeighbourParam::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::MissingNeighbourParam::Builder MapStruct::FindMissingNeighbours2Params::Builder::initParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighbours2Params::Builder::adoptParam(
    ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::MissingNeighbourParam> MapStruct::FindMissingNeighbours2Params::Builder::disownParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::MissingNeighbourParam>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighbours2Params::Reader::hasArea() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighbours2Params::Builder::hasArea() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ResultType::Reader MapStruct::FindMissingNeighbours2Params::Reader::getArea() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindMissingNeighbours2Params::Builder::getArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ResultType::Pipeline MapStruct::FindMissingNeighbours2Params::Pipeline::getArea() {
  return  ::vmtsmap::ResultType::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindMissingNeighbours2Params::Builder::setArea( ::vmtsmap::ResultType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindMissingNeighbours2Params::Builder::initArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighbours2Params::Builder::adoptArea(
    ::capnp::Orphan< ::vmtsmap::ResultType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ResultType> MapStruct::FindMissingNeighbours2Params::Builder::disownArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool MapStruct::FindMissingNeighbours2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindMissingNeighbours2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader MapStruct::FindMissingNeighbours2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::FindMissingNeighbours2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindMissingNeighbours2Results::Builder::setResult( ::capnp::List< ::vmtsmap::MissingNeighbours>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::MissingNeighbours>::Builder MapStruct::FindMissingNeighbours2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::FindMissingNeighbours2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::MissingNeighbours>> MapStruct::FindMissingNeighbours2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::MissingNeighbours>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeeders2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeeders2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::FindSwappedFeeders2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::FindSwappedFeeders2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::FindSwappedFeeders2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeeders2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::FindSwappedFeeders2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeeders2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::FindSwappedFeeders2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeeders2Params::Reader::hasOptions() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeeders2Params::Builder::hasOptions() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AnalysisOptions::Reader MapStruct::FindSwappedFeeders2Params::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindSwappedFeeders2Params::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AnalysisOptions::Pipeline MapStruct::FindSwappedFeeders2Params::Pipeline::getOptions() {
  return  ::vmtsmap::AnalysisOptions::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeeders2Params::Builder::setOptions( ::vmtsmap::AnalysisOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AnalysisOptions::Builder MapStruct::FindSwappedFeeders2Params::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeeders2Params::Builder::adoptOptions(
    ::capnp::Orphan< ::vmtsmap::AnalysisOptions>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AnalysisOptions> MapStruct::FindSwappedFeeders2Params::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AnalysisOptions>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeeders2Params::Reader::hasParam() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeeders2Params::Builder::hasParam() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::FeederParams::Reader MapStruct::FindSwappedFeeders2Params::Reader::getParam() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::vmtsmap::FeederParams::Builder MapStruct::FindSwappedFeeders2Params::Builder::getParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::FeederParams::Pipeline MapStruct::FindSwappedFeeders2Params::Pipeline::getParam() {
  return  ::vmtsmap::FeederParams::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeeders2Params::Builder::setParam( ::vmtsmap::FeederParams::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::FeederParams::Builder MapStruct::FindSwappedFeeders2Params::Builder::initParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeeders2Params::Builder::adoptParam(
    ::capnp::Orphan< ::vmtsmap::FeederParams>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::FeederParams> MapStruct::FindSwappedFeeders2Params::Builder::disownParam() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::FeederParams>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeeders2Params::Reader::hasArea() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeeders2Params::Builder::hasArea() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::ResultType::Reader MapStruct::FindSwappedFeeders2Params::Reader::getArea() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindSwappedFeeders2Params::Builder::getArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::ResultType::Pipeline MapStruct::FindSwappedFeeders2Params::Pipeline::getArea() {
  return  ::vmtsmap::ResultType::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MapStruct::FindSwappedFeeders2Params::Builder::setArea( ::vmtsmap::ResultType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::ResultType::Builder MapStruct::FindSwappedFeeders2Params::Builder::initArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeeders2Params::Builder::adoptArea(
    ::capnp::Orphan< ::vmtsmap::ResultType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::ResultType> MapStruct::FindSwappedFeeders2Params::Builder::disownArea() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::ResultType>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool MapStruct::FindSwappedFeeders2Results::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::FindSwappedFeeders2Results::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Reader MapStruct::FindSwappedFeeders2Results::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder MapStruct::FindSwappedFeeders2Results::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::FindSwappedFeeders2Results::Builder::setResult( ::capnp::List< ::vmtsmap::CellInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::CellInfo>::Builder MapStruct::FindSwappedFeeders2Results::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::FindSwappedFeeders2Results::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellInfo>> MapStruct::FindSwappedFeeders2Results::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellInfo>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::RemoveFromCache2Params::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::RemoveFromCache2Params::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::RemoveFromCache2Params::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::RemoveFromCache2Params::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::RemoveFromCache2Params::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::RemoveFromCache2Params::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::RemoveFromCache2Params::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::RemoveFromCache2Params::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::RemoveFromCache2Params::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::RemoveFromCache2Results::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::RemoveFromCache2Results::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::RemoveFromCache2Results::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void MapStruct::ReloadCellsResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::ReloadCellsResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::ReloadCellsResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::QueryCellsParams::Reader::hasBox() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryCellsParams::Builder::hasBox() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MapStruct::QueryCellsParams::Reader::getBox() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MapStruct::QueryCellsParams::Builder::getBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MapStruct::QueryCellsParams::Pipeline::getBox() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::QueryCellsParams::Builder::setBox( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MapStruct::QueryCellsParams::Builder::initBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryCellsParams::Builder::adoptBox(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MapStruct::QueryCellsParams::Builder::disownBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::QueryCellsResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::QueryCellsResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Reader MapStruct::QueryCellsResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Builder MapStruct::QueryCellsResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::QueryCellsResults::Builder::setResult( ::capnp::List< ::vmtsmap::CellDataInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::CellDataInfo>::Builder MapStruct::QueryCellsResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::QueryCellsResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataInfo>> MapStruct::QueryCellsResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataInfo>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::InsertSignalParams::Reader::hasMsg() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::InsertSignalParams::Builder::hasMsg() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::AddSignalMsg2::Reader MapStruct::InsertSignalParams::Reader::getMsg() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::AddSignalMsg2::Builder MapStruct::InsertSignalParams::Builder::getMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::AddSignalMsg2::Pipeline MapStruct::InsertSignalParams::Pipeline::getMsg() {
  return  ::vmtsmap::AddSignalMsg2::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::InsertSignalParams::Builder::setMsg( ::vmtsmap::AddSignalMsg2::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::AddSignalMsg2::Builder MapStruct::InsertSignalParams::Builder::initMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::InsertSignalParams::Builder::adoptMsg(
    ::capnp::Orphan< ::vmtsmap::AddSignalMsg2>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::AddSignalMsg2> MapStruct::InsertSignalParams::Builder::disownMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::AddSignalMsg2>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::InsertSignalResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::InsertSignalResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::InsertSignalResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::RemoveSignalParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::RemoveSignalParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::RemoveSignalParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::RemoveSignalParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::RemoveSignalParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::RemoveSignalParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::RemoveSignalParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::RemoveSignalParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::RemoveSignalParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::RemoveSignalParams::Reader::hasMsg() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::RemoveSignalParams::Builder::hasMsg() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::DeleteSignalMsg2::Reader MapStruct::RemoveSignalParams::Reader::getMsg() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::vmtsmap::DeleteSignalMsg2::Builder MapStruct::RemoveSignalParams::Builder::getMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::DeleteSignalMsg2::Pipeline MapStruct::RemoveSignalParams::Pipeline::getMsg() {
  return  ::vmtsmap::DeleteSignalMsg2::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapStruct::RemoveSignalParams::Builder::setMsg( ::vmtsmap::DeleteSignalMsg2::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::DeleteSignalMsg2::Builder MapStruct::RemoveSignalParams::Builder::initMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::RemoveSignalParams::Builder::adoptMsg(
    ::capnp::Orphan< ::vmtsmap::DeleteSignalMsg2>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::DeleteSignalMsg2> MapStruct::RemoveSignalParams::Builder::disownMsg() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::DeleteSignalMsg2>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::RemoveSignalResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::RemoveSignalResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::RemoveSignalResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::OnCellChangeParams::Reader::hasInsertIds() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::OnCellChangeParams::Builder::hasInsertIds() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader MapStruct::OnCellChangeParams::Reader::getInsertIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder MapStruct::OnCellChangeParams::Builder::getInsertIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::OnCellChangeParams::Builder::setInsertIds( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void MapStruct::OnCellChangeParams::Builder::setInsertIds(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder MapStruct::OnCellChangeParams::Builder::initInsertIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::OnCellChangeParams::Builder::adoptInsertIds(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> MapStruct::OnCellChangeParams::Builder::disownInsertIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::OnCellChangeParams::Reader::hasUpdateIds() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::OnCellChangeParams::Builder::hasUpdateIds() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader MapStruct::OnCellChangeParams::Reader::getUpdateIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder MapStruct::OnCellChangeParams::Builder::getUpdateIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::OnCellChangeParams::Builder::setUpdateIds( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void MapStruct::OnCellChangeParams::Builder::setUpdateIds(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder MapStruct::OnCellChangeParams::Builder::initUpdateIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::OnCellChangeParams::Builder::adoptUpdateIds(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> MapStruct::OnCellChangeParams::Builder::disownUpdateIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::OnCellChangeResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::OnCellChangeResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::OnCellChangeResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::UpdateCellParams::Reader::hasInserted() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::UpdateCellParams::Builder::hasInserted() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Reader MapStruct::UpdateCellParams::Reader::getInserted() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder MapStruct::UpdateCellParams::Builder::getInserted() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::UpdateCellParams::Builder::setInserted( ::capnp::List< ::vmtsmap::CellDataExt>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder MapStruct::UpdateCellParams::Builder::initInserted(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::UpdateCellParams::Builder::adoptInserted(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>> MapStruct::UpdateCellParams::Builder::disownInserted() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::UpdateCellParams::Reader::hasUpdated() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::UpdateCellParams::Builder::hasUpdated() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Reader MapStruct::UpdateCellParams::Reader::getUpdated() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder MapStruct::UpdateCellParams::Builder::getUpdated() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::UpdateCellParams::Builder::setUpdated( ::capnp::List< ::vmtsmap::CellDataExt>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::CellDataExt>::Builder MapStruct::UpdateCellParams::Builder::initUpdated(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::UpdateCellParams::Builder::adoptUpdated(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::CellDataExt>> MapStruct::UpdateCellParams::Builder::disownUpdated() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::CellDataExt>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::UpdateCellResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::UpdateCellResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::UpdateCellResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void MapStruct::FinishUpdateCellResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::FinishUpdateCellResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::FinishUpdateCellResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void MapStruct::PingRPCResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::PingRPCResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::PingRPCResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::ToCSVParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ToCSVParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ToCSVParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ToCSVParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ToCSVParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ToCSVParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ToCSVParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ToCSVParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ToCSVParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ToCSVParams::Reader::hasFilename() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ToCSVParams::Builder::hasFilename() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::ToCSVParams::Reader::getFilename() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::ToCSVParams::Builder::getFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::ToCSVParams::Builder::setFilename( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::ToCSVParams::Builder::initFilename(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::ToCSVParams::Builder::adoptFilename(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::ToCSVParams::Builder::disownFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::ToCSVResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::ToCSVResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::ToCSVResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::ExportCellCSVParams::Reader::hasMap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ExportCellCSVParams::Builder::hasMap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::Map::Reader MapStruct::ExportCellCSVParams::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::Map::Builder MapStruct::ExportCellCSVParams::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::Map::Pipeline MapStruct::ExportCellCSVParams::Pipeline::getMap() {
  return  ::vmtsmap::Map::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::ExportCellCSVParams::Builder::setMap( ::vmtsmap::Map::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::Map::Builder MapStruct::ExportCellCSVParams::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::ExportCellCSVParams::Builder::adoptMap(
    ::capnp::Orphan< ::vmtsmap::Map>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::Map>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::Map> MapStruct::ExportCellCSVParams::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::Map>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::ExportCellCSVParams::Reader::hasFilename() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::ExportCellCSVParams::Builder::hasFilename() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader MapStruct::ExportCellCSVParams::Reader::getFilename() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder MapStruct::ExportCellCSVParams::Builder::getFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void MapStruct::ExportCellCSVParams::Builder::setFilename( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder MapStruct::ExportCellCSVParams::Builder::initFilename(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void MapStruct::ExportCellCSVParams::Builder::adoptFilename(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> MapStruct::ExportCellCSVParams::Builder::disownFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::capnp::Void MapStruct::ExportCellCSVResults::Reader::getResult() const {
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapStruct::ExportCellCSVResults::Builder::getResult() {
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void MapStruct::ExportCellCSVResults::Builder::setResult( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool MapStruct::GenerateResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GenerateResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MapStruct::GenerateResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GenerateResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MapStruct::GenerateResults::Pipeline::getResult() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GenerateResults::Builder::setResult( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GenerateResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GenerateResults::Builder::adoptResult(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MapStruct::GenerateResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetBoxParams::Reader::hasBox() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetBoxParams::Builder::hasBox() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::vmtsmap::BoxType::Reader MapStruct::GetBoxParams::Reader::getBox() const {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GetBoxParams::Builder::getBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vmtsmap::BoxType::Pipeline MapStruct::GetBoxParams::Pipeline::getBox() {
  return  ::vmtsmap::BoxType::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapStruct::GetBoxParams::Builder::setBox( ::vmtsmap::BoxType::Reader value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::vmtsmap::BoxType::Builder MapStruct::GetBoxParams::Builder::initBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetBoxParams::Builder::adoptBox(
    ::capnp::Orphan< ::vmtsmap::BoxType>&& value) {
  ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vmtsmap::BoxType> MapStruct::GetBoxParams::Builder::disownBox() {
  return ::capnp::_::PointerHelpers< ::vmtsmap::BoxType>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool MapStruct::GetBoxResults::Reader::hasResult() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MapStruct::GetBoxResults::Builder::hasResult() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Reader MapStruct::GetBoxResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder MapStruct::GetBoxResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MapStruct::GetBoxResults::Builder::setResult( ::capnp::List< ::vmtsmap::PointFull>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::vmtsmap::PointFull>::Builder MapStruct::GetBoxResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MapStruct::GetBoxResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::vmtsmap::PointFull>> MapStruct::GetBoxResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::vmtsmap::PointFull>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

}  // namespace

#endif  // CAPNP_INCLUDED_881a44bf3eccf134_
